<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      内存管理 | 印度阿三 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="葛朋">
    
    

    <meta name="description" content="iOS程序的内存布局  Tagged Point  1 从arm64开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。 2 在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用计数等、NSNumber指针存储的是堆中NSNunber对象的地址值。 3 使用Tagged Pointer之">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理 | 印度阿三">
<meta property="og:url" content="http://PGGMan.github.io/2018/07/02/内存管理/index.html">
<meta property="og:site_name" content="印度阿三">
<meta property="og:description" content="iOS程序的内存布局  Tagged Point  1 从arm64开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。 2 在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用计数等、NSNumber指针存储的是堆中NSNunber对象的地址值。 3 使用Tagged Pointer之">
<meta property="og:locale" content="Chinese/English">
<meta property="og:image" content="http://pggman.github.io/2018/07/02/内存管理/my_Memory.png">
<meta property="og:image" content="http://pggman.github.io/2018/07/02/内存管理/my_AutoreleasePoolPage.png">
<meta property="og:image" content="http://pggman.github.io/2018/07/02/内存管理/my_Copy&MutableCopy.png">
<meta property="og:updated_time" content="2018-07-16T13:32:59.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="内存管理 | 印度阿三">
<meta name="twitter:description" content="iOS程序的内存布局  Tagged Point  1 从arm64开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。 2 在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用计数等、NSNumber指针存储的是堆中NSNunber对象的地址值。 3 使用Tagged Pointer之">
<meta name="twitter:image" content="http://pggman.github.io/2018/07/02/内存管理/my_Memory.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">印度阿三</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          I&#39;m my own hero
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">内存管理</h1>

    

    <div class="post-meta">
      <time datetime="2018-07-02" class="post-meta__date date">2018-07-02</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="iOS程序的内存布局"><a href="#iOS程序的内存布局" class="headerlink" title="iOS程序的内存布局 "></a><font color="#037aff" face="黑体">iOS程序的内存布局 </font></h2><p><img src="/2018/07/02/内存管理/my_Memory.png" alt="内存分布图"></p>
<h2 id="Tagged-Point"><a href="#Tagged-Point" class="headerlink" title="Tagged Point "></a><font color="#037aff" face="黑体">Tagged Point </font></h2><ul>
<li>1 从arm64开始，iOS引入了<code>Tagged Pointer</code>技术，用于优化NSNumber、NSDate、NSString等小对象的存储。</li>
<li>2 在没有使用<code>Tagged Pointer</code>之前，NSNumber等对象需要动态分配内存、维护引用计数等、NSNumber指针存储的是<code>堆中NSNunber对象的地址值</code>。</li>
<li>3 使用<code>Tagged Pointer</code>之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据<code>直接存储在了指针</code>中。</li>
<li>4 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据(<code>堆</code>)</li>
<li>5 NSNumber、NSDate、NSString 也会调用<code>objc_msgSend</code>函数，此函数内部对<code>Tagged Point</code>进行了判断。<ul>
<li>比如NSNumber的<code>intValue</code>方法，直接从指针中提取数据，节省了以后的调用开销(过程见 Runtime -&gt;<code>objc_msgSend</code>执行流程)</li>
</ul>
</li>
</ul>
<h3 id="Tagged-Point判断方法"><a href="#Tagged-Point判断方法" class="headerlink" title="Tagged Point判断方法"></a><code>Tagged Point</code>判断方法</h3><ul>
<li>iOS平台：最高有效位是1 (第64bit)</li>
<li>Mac平台: 最低有效位是1 (第0bit) </li>
</ul>
<h2 id="OC对象内存管理"><a href="#OC对象内存管理" class="headerlink" title="OC对象内存管理 "></a><font color="#037aff" face="黑体">OC对象内存管理 </font></h2><ul>
<li>在iOS中，使用<code>引用计数</code>来管理OC对象的内存</li>
<li>一个新创建的OC对象的引用计数+1(1)，当引用计数为0，OC对象就会销毁，释放其占用的内存空间。</li>
<li>调用retain引用计数会+1，调用release会让OC对象的引用计数-1。</li>
</ul>
<h4 id="内存管理经验"><a href="#内存管理经验" class="headerlink" title="内存管理经验"></a><code>内存管理</code>经验</h4><ul>
<li>当调用alloc、new、copy、mutableCopy、方法返回了一个对象。在不需要这个对象时，要调用release或者autorelease来释放它</li>
<li>想拥有某个对象，就让它的引用计数+1(retain)；不想再拥有某个对象，就让它的引用计数-1(release)</li>
</ul>
<h4 id="查看自动释放池-de-函数"><a href="#查看自动释放池-de-函数" class="headerlink" title="查看自动释放池 de 函数"></a>查看自动释放池 de 函数</h4><ul>
<li>私有函数，调用此函数会打印出自动释放池相关信息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_autoreleasePoolPrint(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h2 id="引用计数存储"><a href="#引用计数存储" class="headerlink" title="引用计数存储 "></a><font color="#037aff" face="黑体">引用计数存储 </font></h2><ul>
<li><code>isa_t</code> -&gt; <code>uintptr_t has_sidetable_rc</code></li>
<li>在64bit中，引用计数可以直接存储在优化过得isa指针中，也可能存储在SideTable类中(extra_rc 用19位来存储计数器相关数据,超出后会存储于 has_sidetable_rc结构体内(N - 1))</li>
<li><code>SideTable</code>结构体中<code>refcnts</code>是一个存放着对象引用计数的散列表。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts; </span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"Do not delete SideTable."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> lock() &#123; slock.lock(); &#125;</span><br><span class="line">    <span class="keyword">void</span> unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    <span class="keyword">void</span> forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池 "></a><font color="#037aff" face="黑体">自动释放池 </font></h2><ul>
<li>自动释放池的主要底层数据结构是: <code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code>。</li>
<li>调用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管理的。</li>
<li><code>AutoreleasePoolPage</code>是专属于某一个线程的,结构体内有一个<code>thread</code>属性用来存储它的<code>归属线程</code>。</li>
<li><code>@autoreleasepool{}</code>的调用与<code>__AtAutoreleasePool</code>有关</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// OC MRC 代码</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init] autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成c++代码 相当于</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">		atautoreleasepoolobj = objc_autoreleasePoolPush(); <span class="comment">// 开头调用</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Person *person = [[Person alloc] init] autorelease];</span><br><span class="line">		</span><br><span class="line">		objc_autoreleasePoolPop(atautoreleasepoolobj)     <span class="comment">// 结尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtAutoreleasePool的结构体"><a href="#AtAutoreleasePool的结构体" class="headerlink" title="__AtAutoreleasePool的结构体 "></a><font color="#037aff" face="黑体"><code>__AtAutoreleasePool</code>的结构体 </font></h3><ul>
<li><code>__AtAutoreleasePool</code>结构体内定义了<code>objc_autoreleasePoolPush()</code>和 <code>objc_autoreleasePoolPop()</code>两个函数。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 结构中可以定义函数</span></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line"></span><br><span class="line">  __AtAutoreleasePool() &#123; <span class="comment">// 构造函数。在创建结构体的时候调用</span></span><br><span class="line">  <span class="comment">// atautoreleasepoolobj 是 POOL_BOUNDARY的地址值</span></span><br><span class="line">  atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  __AtAutoreleasePool() &#123;<span class="comment">// 析构函数，在结构体销毁的时候调用</span></span><br><span class="line">  </span><br><span class="line">  objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </span><br><span class="line"> 	   &#123;</span><br><span class="line">      	  <span class="keyword">id</span> *dest;</span><br><span class="line">      	  <span class="comment">// POOL_BOUNDARY 常量 (Null) 最后返回的是它在page中的内存地址</span></span><br><span class="line">      	  </span><br><span class="line">      	  <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">            </span><br><span class="line">            dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">   	     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">        &#125;</span><br><span class="line">     	  assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构 "></a><font color="#037aff" face="黑体"><code>AutoreleasePoolPage</code>的结构 </font></h3><ul>
<li><code>自动释放池</code>通过 <code>__AtAutoreleasePool</code>内部定义的函数来操作<code>AutoreleasePoolPage</code>来管理<code>autorelease对象的地址</code></li>
<li>所有<code>AutoreleasePoolPage</code>对象通过<code>双向链表</code>的形式连接在一起。</li>
<li>每个<code>AutoreleasePoolPage</code>对象占用<code>4096</code>字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放<code>autorelease对象的地址</code></li>
<li>每个<code>AutoreleasePoolPage</code>对象内有固定的<code>7</code>个属性(占56个字节),其余空间(4096 - 56 = 4040 字节)用于存储<code>autorelease对象的内存地址</code></li>
<li><code>next</code>指向了下一个能存放autorelease对象地址的区域</li>
</ul>
<p><img src="/2018/07/02/内存管理/my_AutoreleasePoolPage.png" alt="AutoreleasePoolPage"></p>
<h3 id="自动释放池操作流程结构体"><a href="#自动释放池操作流程结构体" class="headerlink" title="自动释放池操作流程结构体 "></a><font color="#037aff" face="黑体"><code>自动释放池</code>操作流程结构体 </font></h3><h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a><code>@autoreleasepool</code></h4><ul>
<li><code>@autoreleasepool</code>通过<code>__AtAutoreleasePool</code>来操作，通过<code>AutoreleasePoolPage</code>来管理。</li>
</ul>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a><code>objc_autoreleasePoolPush()</code></h4><ul>
<li><code>objc_autoreleasePoolPush()</code> 是调用了 <code>AutoreleasePoolPage</code>结构体内定义的<code>push()</code>函数，首先，将<code>POOL_BOUNDARY</code>入栈，并返回其存储的内存地址</li>
<li>将<code>N</code>个<code>autorelease对象</code>按顺序存储到page中。</li>
<li>当前page满了，就会新创建一个page，把<code>autorelease对象</code>存储到新的page中。</li>
</ul>
<h4 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop()"></a><code>objc_autoreleasePoolPop()</code></h4><ul>
<li><code>objc_autoreleasePoolPop()</code> 是调用了 <code>AutoreleasePoolPage</code>结构体内定义的<code>pop()</code>函数，调用此函数需要传入<code>objc_autoreleasePoolPush()</code>的返回值(<code>POOL_BOUNDARY</code>的内存地址)</li>
<li><code>pop()</code>会从hotpage（最后一页）的最后一个<code>autorelease对象</code>开始调用他们的release方法，直到遇到传入的内存地址，停止。</li>
</ul>
<h2 id="Runloop和Autorelease"><a href="#Runloop和Autorelease" class="headerlink" title="Runloop和Autorelease "></a><font color="#037aff" face="黑体"><code>Runloop</code>和<code>Autorelease</code> </font></h2><ul>
<li>iOS在主线程的Runloop中注册了2个Observer<ul>
<li>第一个Observer监听<code>KCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>
<li>第二个Observer:<ul>
<li>监听了<code>KCFRunloopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()</code>、 <code>objc_autoreleasePoolPush()</code>函数</li>
<li>监听了<code>KCFRunloopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="属性修饰词"><a href="#属性修饰词" class="headerlink" title="属性修饰词 "></a><font color="#037aff" face="黑体">属性修饰词 </font></h2><h4 id="属性-assign"><a href="#属性-assign" class="headerlink" title="属性 - assign"></a>属性 - <code>assign</code></h4><ul>
<li>1 - <code>assign</code> setting方法直接赋值。不会进行引用计数操作。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br></pre></td></tr></table></figure>
<h4 id="属性-retain"><a href="#属性-retain" class="headerlink" title="属性 - retain"></a>属性 - <code>retain</code></h4><ul>
<li>2 - <code>retain</code> setting方法中会判断是不是新值；若是，会release旧值，retain新值<br> 在dealloc中会 release释放对象。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> , <span class="keyword">retain</span>) Dog *dog;</span><br></pre></td></tr></table></figure>
<h4 id="属性-copy"><a href="#属性-copy" class="headerlink" title="属性 - copy"></a>属性 - <code>copy</code></h4><ul>
<li>3 - <code>copy</code> setting方法中会判断是不是新值；若是，会release旧值，copy新值<br> 在dealloc中会 release释放对象<br> 属性不存在 mutableCopy 操作</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> , <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *ary;</span><br></pre></td></tr></table></figure>
<h4 id="属性-weak"><a href="#属性-weak" class="headerlink" title="属性 - weak"></a>属性 - <code>weak</code></h4><ul>
<li>4 - <code>weak</code> 不进行引用计数操作，在其指向对象销毁时，会进行一次清空操作<br>  在setting方法中调用<code>objc_storeWeak</code>函数，会把<code>weak指针</code>在散列表中清除并清空weak指针清空。然后把赋值后的新weak<br>  指针存储到当前OC对象的散列表中(sideTable -&gt; refonts(RefcountMap))</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> , <span class="keyword">weak</span>) Person *p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************** 源码 **********************/</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_storeWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    SideTable *oldTable;  <span class="comment">// 旧得引用计数表,</span></span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作排序顺序相关(锁)</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (<span class="keyword">id</span>)newObj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此weak指针存储在引用计数结构体(sideTable)的散列表(refonts)中，将其取出清空</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新值存储到散列表中</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">           &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性-strong"><a href="#属性-strong" class="headerlink" title="属性 - strong"></a>属性 - <code>strong</code></h4><ul>
<li>5 - <code>strong</code>在setting方法中会对传入的新值进行引用计数操作(retain),降低旧值引用计数(release)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> , <span class="keyword">strong</span>) Person *p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************** 源码 **********************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_storeStrong(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);     <span class="comment">// retain新值</span></span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);   <span class="comment">// release旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OC指针修饰词"><a href="#OC指针修饰词" class="headerlink" title="OC指针修饰词 "></a><font color="#037aff" face="黑体">OC指针修饰词 </font></h2><h4 id="OC指针修饰词-strong"><a href="#OC指针修饰词-strong" class="headerlink" title="OC指针修饰词 - __strong"></a>OC指针修饰词 - <code>__strong</code></h4><ul>
<li>超出<code>__strong</code>修饰指针的作用域后才会释放。对引用计数进行了操作(<code>+1</code>)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line"> &#123; </span><br><span class="line">	__<span class="keyword">strong</span> Person *p1;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		Person *p = [[Person alloc] init];</span><br><span class="line">	</span><br><span class="line">		p1 = p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">// p 释放</span></span><br></pre></td></tr></table></figure>
<h4 id="OC指针修饰词-weak"><a href="#OC指针修饰词-weak" class="headerlink" title="OC指针修饰词 - __weak"></a>OC指针修饰词 - <code>__weak</code></h4><ul>
<li><code>__weak</code>只是<code>对其修饰指针</code>指向的<code>对象</code>进行引用，并没有进行引用计数操作。在<code>对象</code>销毁时，会对<code>对其修饰指针</code>进行一次清空操作。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line"> &#123; </span><br><span class="line">	__<span class="keyword">weak</span> Person *p2;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		Person *p = [[Person alloc] init];</span><br><span class="line">	</span><br><span class="line">		p2 = p;</span><br><span class="line">	&#125;<span class="comment">// p 释放</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="OC指针修饰词-unsafe-unretained"><a href="#OC指针修饰词-unsafe-unretained" class="headerlink" title="OC指针修饰词 - __unsafe_unretained"></a>OC指针修饰词 - <code>__unsafe_unretained</code></h4><ul>
<li><code>__unsafe_unretained</code> 同<code>__weak</code>有些类似，只是<code>对其修饰指针</code>指向的<code>对象</code>进行引用，并没有进行引用计数操作.但是,不会<code>对其修饰指针</code>进行清空操作(还指向原来p的内存地址)。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line"> &#123; </span><br><span class="line">	__<span class="keyword">unsafe_unretained</span> Person *p2;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		Person *p = [[Person alloc] init];</span><br><span class="line">	</span><br><span class="line">		p2 = p;</span><br><span class="line">	&#125;<span class="comment">// p 释放</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此时 p2 仍然指向 p原来的内存地址</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="weak实现原理"><a href="#weak实现原理" class="headerlink" title="weak实现原理 "></a><font color="#037aff" face="黑体"><code>weak</code>实现原理 </font></h2><ul>
<li><p>关于<code>weak</code>的runtime源码 如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;           <span class="comment">// 是否是优化过得isa</span></span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;   <span class="comment">// 是否 没有 弱引用指向它</span></span><br><span class="line">                 !isa.has_assoc  &amp;&amp;           <span class="comment">// 是否 没有 关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;        <span class="comment">// 是否 没有 c++析构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc))      <span class="comment">// 是否 没有 另一个sidetable结构体存储引用计数相关</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 直接释放</span></span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进行相关处理(释放关联对象、weak指针、sidetable 等)</span></span><br><span class="line">    <span class="comment">// 进行 4 5</span></span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">             </span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);  <span class="comment">// 销毁c++析构函数(销毁成员变量)</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj); <span class="comment">// 销毁关联对象</span></span><br><span class="line">        obj-&gt;clearDeallocating();  <span class="comment">// 清空若指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// 是普通指针</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// 是优化过得isa指针 并且有弱引用指针指向它</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7 </span></span><br><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 引用计数存储表(哈希表)</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">    	<span class="comment">// 用对象的内存地址(this)作为key，去SideTables表里去除若指针进行清空</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结一句话: <code>weak修饰的对象指针</code>指向的对象销毁时，会在该对象的dealloc函数中发送消息(调用函数)。去该对象的引用计数表中对weak指针进行清空操作。</p>
</li>
</ul>
<h2 id="copy与mutableCopy"><a href="#copy与mutableCopy" class="headerlink" title=" copy与mutableCopy "></a><font color="#037aff" face="黑体"> <code>copy</code>与<code>mutableCopy</code> </font></h2><ul>
<li>最简洁的两点<ul>
<li>1 改变<code>新值</code>不影响旧值，改变旧值不影响<code>新值</code></li>
<li>2 copy出来的必是<code>不可变</code>，<code>mutableCopy</code>出来的必是<code>可变</code></li>
</ul>
</li>
</ul>
<p><img src="/2018/07/02/内存管理/my_Copy&amp;MutableCopy.png" alt="copy相关"></p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
