{"meta":{"title":"印度阿三","subtitle":"I'm my own hero","description":"Don't encourage you, you can't do it.","author":"葛朋","url":"http://PGGMan.github.io"},"pages":[],"posts":[{"title":"逆向环境搭建","slug":"逆向环境搭建","date":"2018-07-15T12:01:02.000Z","updated":"2018-07-15T12:01:02.263Z","comments":true,"path":"2018/07/15/逆向环境搭建/","link":"","permalink":"http://PGGMan.github.io/2018/07/15/逆向环境搭建/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mach-O","slug":"Mach-O","date":"2018-07-15T12:00:13.000Z","updated":"2018-07-15T12:00:13.708Z","comments":true,"path":"2018/07/15/Mach-O/","link":"","permalink":"http://PGGMan.github.io/2018/07/15/Mach-O/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS签名机制","slug":"iOS签名机制","date":"2018-07-15T11:59:46.000Z","updated":"2018-07-15T11:59:46.111Z","comments":true,"path":"2018/07/15/iOS签名机制/","link":"","permalink":"http://PGGMan.github.io/2018/07/15/iOS签名机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"性能优化","slug":"性能优化","date":"2018-07-11T12:36:45.000Z","updated":"2018-07-11T12:49:53.535Z","comments":true,"path":"2018/07/11/性能优化/","link":"","permalink":"http://PGGMan.github.io/2018/07/11/性能优化/","excerpt":"","text":"耗电来源 CPU处理 Processing ;数据处理计算 网络: Networking :网络请求 定位: Location :用户位置定位 图像: Graphics :图像渲染 耗电优化 尽量降低CPU、GPU功耗 少用定时器 优化I/O操作 尽量不要频繁写入小数据。最好批量一次性写入。 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API，用dispatch_io系统会优化磁盘访问 数据量比较大的，建议使用数据库(比如SQLite CoreData)(数据库怎么优化的？) 网络优化 减少、压缩网络数据(protocol buffer 体积比JSON还小) 上传文件也进行压缩(图片、I/O) 网络请求结果基本一样的可以用缓存(NSMutableURLRequest 然后用NSCache进行缓存) 123NSMutableURLRequestNSCache 尽量使用断点续传 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量下载，减少发送网络请求的数量 定位优化 硬件检测优化 加速剂、陀螺仪、摇晃。会产生动作(motion)事件在不需要检测的场合，应该及时关闭这些硬件 APP的启动 APP的启动可以分为2种 冷启动(Cold Launch): 从零开始启动APP 热启动(Warm Launch): APP已经在内存中，在后台存活着，再次点击图标启动APP APP启动时间的优化，主要是针对冷启动进行优化 通过添加环境变量可以打印出APP的启动时间分析(Edit scheme -&gt; Run -&gt; Arguments(400毫秒以内算正常的) DYLD_PRINT_STATISTICS设置为1(dyld_print_statistics) DYLD_PRINT_STATISTICS_DETAILS设置为1，会展示更加详细的信息 APP的启动过程 APP的冷启动可以概括为3大阶段(注: 需要图) dyld runtime main APP的启动 - dyld dyld (dynamic link editor), Apple的动态链接器，可以用来装载Mach-O文件(可执行文件、动态库等)","categories":[],"tags":[]},{"title":"Block","slug":"Block","date":"2018-07-09T06:09:27.000Z","updated":"2018-07-15T11:48:48.743Z","comments":true,"path":"2018/07/09/Block/","link":"","permalink":"http://PGGMan.github.io/2018/07/09/Block/","excerpt":"","text":"Block block本质上也是一个OC对象，它内部也有一个isa指针 block是封装了函数调用以及函数调用环境的OC对象 block的底层结构如下图所示(OC代码通过clang转成c++代码) xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m 1234567891011121314151617181920212223242526// OC代码 // main.m// GNU//// Created by 印度阿三 on 2018/7/9.// Copyright © 2018年 印度阿三. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int a = 10; NSString *name = @\"abc\"; ^&#123; NSLog(@\"%d--%@\",a,name); &#125;(); return 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// CPP代码/** __main_block_impl_0 -&gt; impl*/struct __block_impl &#123; void *isa; // 说明block是个OC对象 int Flags; int Reserved; // void *FuncPtr; // 存储着 __main_block_func_0函数调用的内存地址 // __main_block_func_0: block内部代码封装成的函数&#125;;/** block 结构体*/struct __main_block_impl_0 &#123; struct __block_impl impl; // 是个结构体变量，不是指针。 struct __main_block_desc_0* Desc; // 捕获的变量 int a; NSString *name; // 构造函数 (类似于OC的init方法)，返回结构体对象（__main_block_impl_0） __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_name, int flags=0) : a(_a), name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;/** block内部代码封装成的函数*/static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy NSString *name = __cself-&gt;name; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_g8_prk3m15j55xgythlcdcnj91c0000gn_T_main_f5d28b_mi_1,a,name); &#125;/** block内部内存管理相关代码*/ static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;name, (void*)src-&gt;name, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;/** block内部内存管理相关代码*/ static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;name, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;/** block 描述信息*/static struct __main_block_desc_0 &#123; size_t reserved; // 该Block升级后所存放的区域，栈block -&gt; 堆block size_t Block_size; // block占用多少内存 void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;/**main函数*/int main(int argc, char * argv[]) &#123; // @autoreleasepool 内存管理中会降到它的作用 /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int a = 10; NSString *name = (NSString *)&amp;__NSConstantStringImpl__var_folders_g8_prk3m15j55xgythlcdcnj91c0000gn_T_main_f5d28b_mi_0; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, name, 570425344))(); return 0; &#125;&#125;/************************* Block结构体的另外一种写法 *************************/struct __main_block_impl_0 &#123; /********** impl ******/ void *isa; int Flags; int Reserved; void *FuncPtr; /********** impl ******/ struct __main_block_desc_0* Desc; int a; NSString *name; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_name, int flags=0) : a(_a), name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;/************** block调用**************/// 第一个参数是block，后面是参数.block -&gt;funPtr(myblock) block调用过程: 当block调用外部局部变量时,会进行变量捕获,通过__main_block_copy_0、__main_block_dispose_0对变量进行内存管理。block内部的代码会封装成__main_block_func_0函数。并存储到__main_block_impl_0(block结构体)中的funPtr中。 Block使用场景 12345678910111213141516171819202122232425262728#import \"Person.h\"@interface Person ()/**block作为属性使用*/// 返回值(^名称)(参数)@property (nonatomic ,copy) void(^myBlock)(void);@end@implementation Person- (void)testTask&#123; // 传递block !self.myBlock?:self.myBlock();&#125;/**block作为函数参数*/// (返回值 (^)(参数)名称)- (void)makeBlockTask:(void (^)(NSString *))callback&#123; /**Tagger Pointer*/ NSString * str = @\"123\"; // 执行block callback(str);&#125;@end Block类型 block分为三种，全局Block、栈Block、堆Block。 iOS程序加载到内存中,由低到高(内存地址). 分为 保留区、_TEXT(代码段)、_DATA(数据段)、heap(堆)、stack(栈)、内核区。 保留区:由于用到了ASLR技术(地址空间布局随机化、iOS4.3开始)。保留区分为偏移区、_PAGEZERO、Header Load commands.内存管理和mach-O文件中会详细说，这里只需要关注_DATA(数据段)、heap(堆)、stack(栈)。 全局Block存放在_DATA(数据段)；栈Block存在在stack(栈)；堆Block存放在heap(堆)。 clang类型 OC类型 存储区域 决定因素(环境) _NSConcreteGlobalBlock _NSGlobalBlock_ 静态数据区 没有访问auto变量 _NSConcreteStackBlock _NSStackBlock_ 栈 访问了auto变量 _NSConcreteMallocBlock _NSMallocBlock_ 堆 _NSStackBlock_调用了copy Block变量捕获(capture) Block变量捕获的目: 为了保证Block内部能够正常访问外部的变量。 说白了就是受外部变量作用域影响 原因： 全局变量，全局都可以访问，不会出现block执行前被释放问题，所以不需要捕获 局部变量 auto，可能block执行前就出了作用域被释放。所以需要变量捕获 局部变量 static，静态变量时存放在_DATA数据段中，不会被释放。但是，指向它的指针会被释放。block会进行指针复制。所以需要变量捕获 代码如下: 全局变量: block结构体内并没有关于全局字符串相关的信息。没有捕获(直接访问) 1234567891011121314151617181920212223242526272829/********************** OC ***********************/NSString *name = @\"abc\";int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; ^&#123; NSLog(@\"%@\",name); &#125;(); return 0; &#125;&#125;/********************** cpp ***********************/// 定义的全局字符串NSString *name = (NSString *)&amp;__NSConstantStringImpl__var_folders_g8_prk3m15j55xgythlcdcnj91c0000gn_T_main_aa8b72_mi_0;// block结构体struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 局部变量 auto: block结构体内生了一个NSString *name字符串。进行了变量捕获(值传递) 12345678910111213141516171819202122232425262728/********************** OC ***********************/int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // 默认前面是有 auto 的 NSString *name = @\"abc\"; ^&#123; NSLog(@\"%@\",name); &#125;(); return 0; &#125;&#125;/********************** cpp ***********************/// 定义的全局字符串struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *name; // 关注这里 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_name, int flags=0) : name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 局部变量 static: block结构体内生了一个NSString *name指向外部static修饰指针所指向的内存地址。进行了变量捕获(指针传递) 12345678910111213141516171819202122232425262728/********************** OC ***********************/int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // 默认前面是有 auto 的 NSString *name = @\"abc\"; ^&#123; NSLog(@\"%@\",name); &#125;(); return 0; &#125;&#125;/********************** cpp ***********************/// 定义的全局字符串struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *name; // 关注这里 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_name, int flags=0) : name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; Block的copy 三种block进行copy操作的变化(全局、堆、栈) block 的类 存储区域 copy效果 _NSConcreteGlobalBlock 数据段 什么也不做 _NSConcreteStackBlock 栈 从栈到堆 _NSConcreteMallocBlock 堆 引用计数增加 ARC环境下: 编译器会根据情况自动将栈上的block复制到堆上 block作为函数返回值 block被强指针引用 block作为Cocoa API中方法名含有usingBlock的方法参数时 block作为GCD API的方法参数时 block属性建议书写1234567891011/** MRC下，block需要手动copy,属性copy会在seetting方法中对新值进行copy操作*/@property (copy, nonatomic) void(^myBlock)(void);/** ARC下，编译器已经就行了自动copy操作，用copy或strong 来修饰都可以*/@property (copy, nonatomic) void(^myBlock)(void);// 关于属性关键字 请看内存管理 block访问 OC对象类型的auto变量。 全局block_NSConcreteGlobalBlock 方法变量是安全的。因为它存储在数据段，并且它所访问的外部变量也是安全的(非auto。不会有超出作用域的危险)。所以全局block进行copy后自身没变化，也不会对它访问的变量产生影响、 栈blockNSConcreteStackBlock : 栈block是不会对外部变量进行引用计数操作的(强、弱引用)，不管修饰词是（__strong、__weak、__unsafe__unretained）,都是弱引用。 当它进行copy时会调用block内部的copy函数(_Block_object_assign()) _Block_object_assign()函数会根据auto变量的修饰符（__strong、__weak、__unsafe__unretained）做出相应的操作，形成强引用(retain)或者弱引用。 12345678// copy函数static void __main_block_copy_0( struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;name, (void*)src-&gt;name, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125; 堆block _NSConcreteMallocBlock 会对访问的外部对象类型的的auto变量 进行引用计数(强弱引用操作。根据修饰词) Block 与OC对象类型的修饰词 __block __block 可以用于解决block内部无法修改auto变量值得问题(auto变量默认 变量捕获值传递) __block 不能修饰全局变量、静态变量(直接访问、指针传递)。 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Person.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // 修饰基本数据类型auto变量 __block int a = 10; // 修饰OC对象类型auto变量 __block Person *p = [[Person alloc] init]; return 0; &#125;&#125; 12345678910111213141516171819202122232425#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Person.h\"int b = 30; // 定义全局变量int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; //1 修饰静态变量 // 报错: __block attribute not allowed, only allowed on local variables __block static int c = 20; //2 修饰OC对象类型auto变量 NSLog(@\"%p\",&amp;b); __block int b; NSLog(@\"%p\",&amp;b); /** 打印结果: 2018-07-11 21:07:56.717418+0800 BlockDemo[2325:777978] 0x10c3ff1b8 2018-07-11 21:07:56.718018+0800 BlockDemo[2325:777978] 0x7ffee3803088 证明__block修饰的 b 相当于新定义的变量 */ return 0; &#125;&#125; __block实现原理 编译器会将__block变量包装成一个对象 通过观看下面代码，可以看出auto变量被包装成了 __Block_byref_a_0 结构体(结构体名：__Block_byref_变量名_0) 12345678910111213141516171819202122232425262728293031323334/*************************** oc 代码 *****************************/ __block int age = 10;^&#123; NSLog(@\"%d\", age)&#125;();/*************************** cpp 代码 *****************************/ int b = 30; // 定义的全局变量// auto变量 被__block包装成的 结构体struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; // 指向结构体自身的指针 int __flags; int __size; int a; // __block修饰的 auto变量。指向了外部的 &#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // 这里出现了一个 __Block_byref_a_0 类型的结构体指针 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; __Block_byref_a_0内部的auto 变量: 与外部的同名auto变量(此处是变量 int a)指向的内存地址一样。 当block从栈copy到堆时，auto变量也会被拷贝到堆内 __block的内存管理 当block在栈上时，并不会对__block变量产生强引用 应为栈block的生命周期与auto变量的生命周期相同，所以不需要强引用，为__block变量衍生的结构体保命 当block被copy到堆时 会调用block内部的copy函数 copy函数内部会调用_Block_object_assign函数。 _Block_object_assign函数会对__block变量形成强引用(retain) __main_block_copy_0内部会调用__Block_objct_assign函数，此函数(后者)会根据所指向对象的修饰符(__strong、__weak、__unsafe_unretained)做出相应的操作，形成强引用(retain)或者弱引用(注意: 这里仅限于ARC时，MRC时不会自动retain) 当block从堆中移除时 会调用block内部的dispose函数 dispose函数内部会调用__Block_object_dispose函数 _Block_object_dispose函数会自动释放引用的__block变量（release） __block 的__forwarding指针12345678// __block修饰 auto变量a 生成的结构体struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; // forwarding指针 int __flags; int __size; int a; &#125;; 全局block: 不会生成次结构体, 因为全局block是不访问auto变变量产生的，而__Block_byref_a_0只有在__block修饰auto变量时才会产生。两者是矛盾的。 栈block: __forwarding指针指向它的结构体本身。 堆block: 堆block是栈blockcopy了一份放到了堆上。栈block的__forwarding指针指向堆block的 __Block_byref_a_0结构体，而堆block的__forwarding指针指向了它的结构体本身、 block的内存管理函数操作__main_block_copy_0、__main_block_dispose_0123456789101112// retainstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// releasestatic void __main_block_dispose_0(struct __main_block_impl_0*src)&#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; 这两个函数会根据最后一个常量(此处为 8)决定对传入的变量(此处为 a)怎样进行内存管理(此处是 __block变量) 对象 – BLOCK_FIELD_IS_OBJECT (3) __block 变量 – BLOCK_FIELD_IS_BYREF (8) __weak __weak可以用于解决block循环引用问题(用来修饰OC对象，修饰基本数据类型会报警告) 用法如下 1__weak typeof(self) weakSelf = self; __weak修饰的OC变量在block结构体内会有__weak标记。在调用__main_block_copy_0、__main_block_dispose_0函数时，虽然传入的常量也是3(BLOCK_FIELD_IS_OBJECT)。但是他们对标记为__weak的OC对象不会进行引用计数操作(强引用) __strong __strong的作用是确保block内其所修饰的OC对象不会被释放。在调用__main_block_copy_0、__main_block_dispose_0函数时，会对其修饰的对象进行引用计数相关的操作。 用法如下:12345678910111213141516int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; Person *P = [[Person alloc] init]; __weak typeof(P) weakP = P; void (^myBlock)(void) = ^&#123; __strong typeof(P) strongP = weakP; NSLog(@\"%@\",strongP.name); &#125;; myBlock(); return 0; &#125;&#125;","categories":[],"tags":[]},{"title":"Runtime","slug":"Runtime","date":"2018-07-03T01:52:06.000Z","updated":"2018-07-10T02:13:15.874Z","comments":true,"path":"2018/07/03/Runtime/","link":"","permalink":"http://PGGMan.github.io/2018/07/03/Runtime/","excerpt":"","text":"Runtime Objective-C是一门动态性比较强的变成语言，跟C、C++等语言由着很大的不同 Objective-C的动态性是由Runtime API来支撑的 Runtime API提供的借口基本都是C语言的，源码由C\\C++汇编语言编写 isa指针 要想学习Runtime,首先要了解它的底层的一些常用数据结构，比如isa指针 在arm64之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址 从arm64之后，对isa进行了优化，变成了一个共用体(union)结构，还使用位域(: 1 (占用一位))来存 储更多的信息 isa指针结构 12345678910111213141516171819202122/** arm64 架构 */union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t nonpointer : 1; // 是否是优化过的isa指针。0:代表普通指针，存储着Class / Meta-Class对象的内存地址；1: 代表优化过，使用位域和共用体存储更多的信息。 uintptr_t has_assoc : 1; // 是否设置过关联对象。若没有，释放时会更快(release源码中会进行判断，只有好几个条件同时满足才会释放更快) uintptr_t has_cxx_dtor : 1; // 表示该对象是否有 C++ 的析构函数，若没有，释放时会更快.(release源码会判断，只有好几个条件同时满足才会释放更快) uintptr_t shiftcls : 33; // 存储着Class / Meta-Class对象的内存地址信息(相当于普通isa指针的作用) uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被若指针指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在isa中。若为1，那么引用计数会存储在一个叫sideTable的类属性中(内存管理中会提到) uintptr_t extra_rc : 19; // 用19位来存储计数器相关数据,超出后会存储于 has_sidetable_rc结构体内(N - 1) &#125;;&#125; Class 结构图如下 objc_class结构体 Class的底层实现:objc_class 123456struct objc_class &#123; Class isa; // class / Meta-calss 指针 Class superclass; // 父类指针 cache_t cache; // 方法缓存 (哈希表) class_data_bits_t bits; // 用于获取具体的类信息&#125; FAST_DATA_MASK 掩码,objc_class中的bits属性&amp;(于) FAST_DATA_MASK 可以获取到 class_rw_t c结构体 class_rw_t结构体 objc_class -&gt; bits -&gt; data() 存储类 加载完成 后的相关信息。此结构体是类加载的时候创建的(例如 里面的方法列表、属性列表、协议列表，不光存储着当前类的，而且还包括分类的、父类的) 12345678910111213141516171819struct class_rw_t&#123; uint32_t flags; uint32_t version; const class_ro_t *ro; // 存储着类中定义的成员变量、方法、协议等信息(只读) method_list_t * methods; // 方法列表(分类 + (ro -&gt; baseMethodList)) 注意顺序，分类在前 property_list_t * properties; // 属性列表(分类 + (ro -&gt; ivars)) 注意顺序，分类在前 property_list_t * protocols; // 协议列表(分类 + (ro -&gt; baseProtocols)) 注意顺序，分类在前(只读) Class firstSubclass; Class nextSiblingClass; char *demangledName; // 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。&#125; /** firstSubclass 与 nextSiblingClass 在 static inline void foreach_realized_class_and_subclass( Class top, std::function&lt;void (Class)&gt; code) 中用到，此函数是作用是 Enumerates a class and all of its realized subclasses. */ class_ro_t结构体 class_rw_t -&gt; ro 此结构体存储着当前类的相关信息 12345678910111213141516171819202122struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; // 实例对象的内存地址(起点) uint32_t instanceSize; // (instance)实例对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; // 成员变量的布局方式(内存对齐加载到内存和释放的时候都需要用到它来计算区域) const char * name; // 类名 method_list_t * baseMethodList; // 方法列表(当前类中定义的成员变量) protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表(只读) const uint8_t * weakIvarLayout; // 弱成员变量的布局方式(内存对齐，释放对象的时候用来计算释放内存区域的。原来以为是哈希表的掩码，幸亏查了半天资料,最后在苹果开发者文档中找到了相关的资料) property_list_t *baseProperties; // 属性列表(当前类中定义的属性) method_list_t *baseMethods() const &#123; // baseMethodList return baseMethodList; &#125;&#125; method_t结构体 class_rw_t里面的methods、properties、protocols是二维数组，包含了类的初始内容、分类的内容(分类在前)* 分类在前: 编译时，是现将class_ro_t中的信息拷贝过来，然后通过分类信息长度，把数组内容向后移动位置，把分类信息放到前面 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 class_rw_t和class_ro_t中都包含着method_t结构体(方法结构体) 12345struct method_t &#123; SEL name; // 方法名 const char *types; // 编码(返回值类型、参数类型。关注一下@encode指令) IMP imp; // 指向函数的指针 (函数地址)&#125; IMP代表函数的具体实现 SEL代表方法\\函数名，一般叫做选择器,底层结构跟char *类似 可以通过@selector()和sel_registerName(char *)获得 可以通过sel_getName()和NSStringFromSelector()转成字符串 不同类中的相同名字的方法，所对应的选择器是相同的。 types包含了函数返回值，参数编码的字符串 方法查找 方法查找可以分为两部分 1 是有关于方法缓存 2 方法列表及父类查找 方法缓存 objc_class -&gt; cache Class内部结构中有个方法缓存cache(cache_t),用散列表(哈希表)来缓存曾经调用过得方法，可以提高方法查找的速度 1234567891011121314// cachestruct cache_t &#123; struct bucket_t *_buckets; //散列表 mask_t _mask; // 编码(返回值类型、参数类型。关注一下@encode指令) mask_t _occupied; // 已经缓存的方法数量 &#125; // bucket_tstruct bucket_t &#123; cache_key_t _key; // SEL作为key (_key = SEL &amp; _mask) IMP _imp; // 函数的内存地址 &#125; 当方法/被调用后就会存储到cache散列表中，调用者类中没有会通过superClass指针去父类查找，找到后会存储到调用者的cache散列表中 cache的实现原理是空间换时间，SEL&amp;_mask(掩码)得到角标，直接通过角标去IMP，存储的过程中:发现当前角标下已经有IMP会向上移动当前角标，到最前面后会从尾部继续找，直到找到位置为止。当找不到为止就会放弃当前cache内存空间，从新建立一个哈希表并且扩容。 objc_msgSend执行流程 runtime的源码基本是由C C++ 和汇编实现的，向一些调用频次高(objc_msgSend)是用汇编实现的 源码 ENTRY(宏)入口 12345678910/** objc_msgSend(p,sel_registerName(\"eat\")) 内部实现: （汇编） 1.先判断 p(消息接收者) 是否存在。若不存在直接退出函数调用 2.若receiver(p)存在， 去读取缓存.如果存在就直接调用 3.若缓存中没有函数,会去调用另一个宏，再去查看一下缓存(以防手动添加方法) 4.当这次查缓存也没有找到方法时，去遍历方法列表里面找(如果排好序的二分查找，没有排好序的线性查找),找到方法后边方法填充到缓存 */ 源码如下 流程如下 objc_msgSend动态解析 当objc_msgSend()查找方法失败后，就会来到此步 流程如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/************************ Main.m ************************/#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Student.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; Student *p = [[Student alloc] init]; [p test]; [Student eat]; return 0; &#125;&#125;/*********************** .h *************************/#import \"Person.h\"@interface Student : Person- (void)test;+ (void)eat;@end/************************ .m ************************///// Student.m// RuntimeDemo//// Created by 印度阿三 on 2015/5/27.// Copyright © 2018年 印度阿三. All rights reserved.//#import \"Student.h\"#import &lt;objc/runtime.h&gt;@implementation Student+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //1 判断是否是想要实现的方法 if (sel == sel_registerName(\"test\")) &#123; // 2 创建Method 消息对象 Method method = class_getInstanceMethod(self, @selector(other)); /** 1 被添加方法的类对象 2 添加的方法名 SEL 3 添加的方法地址 IMP 4 添加的方法Types (字符串组成；里面包含返回值类型、参数类型) */ class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method)); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;+ (BOOL)resolveClassMethod:(SEL)sel&#123; // 1判断是否是要实现的类方法 // sel_registerName(\"eat\") 等价于 @selector(@\"eat\") if (sel == sel_registerName(\"eat\")) &#123; // 2创建类方法 Method method = class_getClassMethod(self, sel_registerName(\"classError\")); /** 1 被添加方法的元类对象 |_(注意是 meta-class)_| 2 添加的方法名 SEL 3 添加的方法地址 IMP 4 添加的方法Types (字符串组成；里面包含返回值类型、参数类型) */ class_addMethod(objc_getMetaClass(class_getName(self)), sel, method_getImplementation(method), method_getTypeEncoding(method)); // 标记已经解析 return YES; &#125; // 没有解析 return [super resolveClassMethod:sel];&#125;- (void) other&#123; NSLog(@\"%s\",__func__); &#125;+ (void)classError&#123; NSLog(@\"%s\",__func__);&#125;@end objc_msgSend消息转发 当消息解析失败后会来到此步 流程如下 123456789101112131415161718192021// 备胎方法: 需要返回一个可以处理方法的对象/类对象// 对象方法 走这里 // (对象方法找不到会调用用此方法)- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [[Car alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;// 类方法 走这里// (类方法找不到会盗用此方法)+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"eat\")) &#123; return [[Car alloc] init]; // objc_sendMsg([[Car alloc] init], \"eat\") &#125; // 如果没有返回 return [super forwardingTargetForSelector:aSelector];&#125; 123456789101112131415161718192021222324252627282930313233// 消息签名: 不签名直接调用doesNotRecognizeSelector方法崩溃；实现后会调用forward方法// 对象方法 // 自己实现此方法，(对象方法签名)- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];; &#125; return [super methodSignatureForSelector:aSelector];&#125;// 类方法 // 自己实现此方法，(对象方法签名)+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];; &#125; return [super instanceMethodSignatureForSelector:aSelector];&#125;/**********************************************************************/// 对象方法 走这里- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 里面可以不做操作，但是必须实现此方法， // 若不实现: unrecognized selector sent to instance &#125;// 类方法 走这里+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@\"122342525\"); &#125; Runtime - API12 面试题相关 1 - 讲一下消息转发机制 12 2 - 消息转发机制流程 12 3 - 什么是Runtime? 平时项目中有用过吗 ? OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行。 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 平时编写的OC代码，底层都是转换成了Runtime API进行调用 * 利用关联对象(AssociatedObject)给分类添加属性 * 遍历类的所有成员变量(修改textField的占位文字颜色、字典转模型、自动归档解挡) * 交换方法(实现hook系统方法功能) * 消息转发机制解决方法找不到的异常问题(weak底层实现也是依赖于runtime) * ....... 4 - 下面一段代码打印结果是什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@interface Studenrt : Person- (void) test;@end@implementation Student- (void)test1&#123; NSLog(@\"%@\",[self class]); NSLog(@\"%@\",[super class]);&#125;- (void)test2&#123; BOOL rest1 = [[NSObject class] isKindOfClass:[NSObject class]]; BOOL rest2 = [[NSObject class] isMemberOfClass:[NSObject class]]; BOOL rest3 = [[Person class] isKindOfClass:[Person class]]; BOOL rest4 = [[Person class] isMemberOfClass:[Person class]]; NSLog(@\"%d %d %d %d\",rest1,rest2,rest3,rest4);&#125;@end`/** test1答案: [self class] 通过isa指针找到类对象: Student [super class] 通过isa指针找到类对象: 再通过superClass指针找到父类 person*/``/** test2答案: 打印结果为 1 0 0 0 \"isKindOfClass:\" 用来判断某个对象是否属于某个类，或者是属于某个派生类。\"isMemberOfClass:\" 用来判断某个对象是否为当前类的实例ps： sMemberOfClass不能检测任何的类都是基于NSObject类这一事实， 而isKindOfClass可以。*/5 - 以下代码能不能执行成功？如果可以，打印结果是什么？@interface Studenrt : NSObject@property (nonatomic, copy) NSString *name;- (void)print;@end@implementation Student- (void)print&#123; NSLog(@\"my name's %@\", self.name);&#125;@end/****/@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id cls = [Person class]; void *objc = &amp;cls; [(__bridge id)obj print];&#125;/**答案: 能执行，执行结果是: my name's &lt;ViewController: 0x60c0000e1a00&gt; 原因： */@end 5 - 你了解isa指针吗 1234/** 答: isa指针在arm64之前是存储 Class / Meta-class地址值的指针；之后isa利用到了共用体(union)的数据结构，用64位(8个字节)来存储更多的信息, 其中33位是存储Class / Meta-Class地址信息，其他存储其他一些信息*/ 1 - 讲一下OC的消息机制 1 OC中方法的调用其实都是转成了objc_msgSend函数的调用，给receiver(方法调用者)发送了一条消息(selector方法名) 2 objc_msgSend底层有3大阶段 - 消息发送(当前类、父类中查找) - 动态方法解析 - 消息转发 2 - @dynamic与@synthesize 3 - isKingOfClass 与 isMemeberOfClass的区别 isKindOfClass 会通过superclass指针往上找，判断是否是其或者其子类实例对象 isMemeberOfClass 只通过isa指针只判断当前类对象 4 - super 做了什么, [super classs] 打印结果是什么 1234567891011121314151617181920212223242526272829// super 底层源码struct objc_super&#123; __unsafe_unretained _Nonnull id receiver // 方法接收者 __unsafe_unretained_Nonnull Class super_class // 消息接收者的父类:它的作用是告诉函数找方法时,从父类的方法列表里开始找&#125;- (void)test&#123; [super run]; /** struct objc_super arg = &#123;self, [Person class]&#125;; // Person为suoer的父类类对象 objc_msgSendSuper(arg, sel_registerName(\"run\")); */&#125;/**class底层实现*/- (Class) class:(id)receiver (SEL)__cmd&#123; return object_getClass(\"self\")&#125;/**superclass底层实现*/- (Class) superclass:(id)receiver (SEL)__cmd&#123; return class_getSuperclass(object_getClass(self));&#125; super底层调用了objc_sendSendSuper(,)函数；[super classs]打印结果是 Person(self的父类)，class的底层调用时object_getClass()函数，消息接收者是self.所以会有此结果 super的调用，消息接收者仍然是当前对象，查找方法是从父类开始查找 5 消息转发有什么用途 解决方法找不到的错误，收集错误发送到服务器 解决循环引用问题(利用中间对象，并实现方法转发来解决循环引用问题) 6 消息转发-问题收集 NSProxy 7 - Hook(交换)系统方法 应用场景 hook 按钮点击 hook 设置字体做适配 hook 可变字典数组set方法（防止传nil） hook 按钮 1234567891011121314151617181920212223242526272829303132333435//// UIButton+Hook.m// hookControlDemo//// Created by 印度阿三 on 2018/6/1.// Copyright © 2018年 印度阿三. All rights reserved.// #import \"UIButton+Hook.h\" #import &lt;objc/runtime.h&gt;@implementation UIButton (Hook)+ (void)load&#123; //1.1 获取系统方法(直接从原类的rw_t结构体中的method_array_t里面取) Method method = class_getInstanceMethod(self, sel_registerName(\"sendAction:to:forEvent\")); //1.2 获取分类定义的方法(也会存放到原类的rw_t结构体中method_array_t的数组里面) Method method2 = class_getInstanceMethod(self, @selector(pg_sendAction:to:forEvent:)); // 2 进行交换方法(交换的是rw_t结构体中method_array_t的数组中的method_t中的IMP) // 当调用此方法时会清空缓存 method_exchangeImplementations(method, method2);&#125;// 分类中实现的方法- (void)pg_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123; NSLog(@\"hook\"); /** 调用此方法 相当于调用系统的 sendAction:to:forEvent: 方法 (因为系统的sendAction 与 ps_sendAction的结构体中的IMP已经交换了) */ [self pg_sendAction:action to:target forEvent:event];&#125;@end hook 可变数组 12345678910111213141516171819202122#import \"NSMutableArray+hook.h\"#import &lt;objc/runtime.h&gt;@implementation NSMutableArray (hook)+ (void)load&#123; // 正常情况下load调用一次,但是某些特殊情况下可能调用多次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型 Class cls = NSClassFromString(@\"__NSArrayM\"); Method method = class_getInstanceMethod(cls, @selector(insertObject:atIndex:)); Method method2 = class_getInstanceMethod(cls, @selector(pg_insertObject:atIndex:)); method_exchangeImplementations(method, method2); &#125;);&#125;- (void)pg_insertObject:(id)anObject atIndex:(NSUInteger)index&#123; if (!anObject)return; [self pg_insertObject:anObject atIndex:index];&#125;@end","categories":[],"tags":[]},{"title":"Git","slug":"Git","date":"2018-07-02T11:24:06.000Z","updated":"2018-07-07T13:46:53.777Z","comments":true,"path":"2018/07/02/Git/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/Git/","excerpt":"","text":"1 创建新分支(本地和远程)12345678//1 创建dev_pg分支git branch dev_pg //2 切换到新分支(dev_pg)git checkout dev_pg//3 创建并推送代码到远程分支(dev_pg)git push origin dev_pg 2 删除分支12345//1 删除本地分支(dev_pg)git branch -D dev_pg//2 删除远程分支(dev_pg)git branch -r -D origin/dev_pg 3 查询分支12345678// 1 列出所有分支(本地及远程) -a（all的意思）git branch -a// 2 列出远程分支 -r(remote)git branch -r // 3 列出本地分支 -l(local)git branch -l 4 查询本地git状态1git status 5 合并代码1234567891011121314//1 切换到合并分支 (例如dev分支开发，需要合并到master分支。则先切换到master分支)git checkout master//2 合并代码git merge dev//3 查看是否有冲突git status//4 再次拉一次代码git pull origin master//5 推送到远程git push origin master 6 打标签(tag) 我们常常在代码封板时,使用git 创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的. (1): 轻量级的 它其实是一个独立的分支,或者说是一个不可变的分支.指向特定提交对象的引用. (2):带附注的 实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证,电子邮件地址和日期，一般我们都建议使用含附注型的标签，以便保留相关信息. 1234567891011121314151617181920//1 创建taggit tag -a V1.2 -m &apos;WebSite version 1.2&apos;//2 查看taggit tag//3 查看tag描述内容git tag show V1.2//4 推送的远程git push origin --tags//5 删除本地标签git tag -d V1.2//6 删除远程标签git push origin :refs/tags/V1.2//7 获取远程标签版本下的分支git fetch origin tagV1.2 7 查看分支链接地址12345//1 查看远程分支地址（fetch push）git remote -v//2git remote show origin 8 更改文件夹名字12// 将abc文件夹改名为aaamv abc aaa 9 忽略文件123456789101112131415// 创建忽略文件$ touch .gitignore// 忽略文件内容(找到对应的文件复制内容)NSString *gitignore = @\"https://github.com/github/gitignore\";/** 忽略用户操作信息(文件夹位置调整等) */// 删除用户操作文件 (工程有修改时，使用git status能查到下面的文件 *请见附录1*)$ git rm --cached XXX.xcodeproj/project.xcworkspace/xcuserdata/mac.xcuserdatad/UserInterfaceState.xcuserstate// 提交本地库$ git commit -m \"Removed the stupid strange file that shouldn't be tracked\"// 推送到远程服务$ git push","categories":[],"tags":[]},{"title":"Cocapods","slug":"Cocapods","date":"2018-07-02T09:57:48.000Z","updated":"2018-07-09T05:52:15.831Z","comments":true,"path":"2018/07/02/Cocapods/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/Cocapods/","excerpt":"","text":"1 删除源12 // (sudo是root级别的指令)$ sudo gem sources -r https://rubygems.org/ 2 添加源1$ sudo gem sources -a https://gems.ruby-china.org/ 3 查看源1$ gem sources -l 4 初始化环境1$ sudo gem install cocoapods 5 查看版本1$ pod --version 6 安装(下载)1$ pod setup 框架支持CocoapodsSpec文件1234567891011121314151617181920212223//1 Spec文件配置相关Pod::Spec.new do |s| #s.name = \"PGTimer\" // 框架名称s.version = \"0.0.1\" // 框架版本号s.summary = \"all kinds of categories for iOS develop\" //摘要:简单描述s.description = &lt;&lt;-DESC this project provide all kinds of categories for iOS developerDESC //详细描述s.homepage = \"https://github.com/PggMan/PGTimerDemo\" //项目主路径s.license = \"MIT\" // 开源许可 级别与作用见下图s.author = &#123;&#123; \"PggMan\" =&gt; \"pg890101@gmail.com\" &#125; //作者邮箱名、邮箱地址s.platform = :ios // 框架相关平台s.source = &#123; :git =&gt; \"https://github.com/PggMan/PGTimerDemo.git\", :tag =&gt; s.version &#125; // 下载路径、版本号 注意路径结尾必须添加.git。不然Cocopods不会会报警告\"- WARN | github_sources: Github repositories should end in `.git`.\" 不会通过的s.source_files = \"PGTimerDemo/PGTimer/*.&#123;h,m&#125;\"//被管理文件在项目中的路径s.exclude_files = \"Classes/Exclude\" //需要忽略管理文件夹内的文件s.public_header_files = \"iOS_Category/Classes/UIKit/UI_Categories.h\"，\"iOS_Category/Classes/Foundation/Foundation_Category.h\"，\"iOS_Category/Classes/**/*.h\" // 公开头文件路径s.requires_arc = true // 是否是ARC模式end Spec权限等级 1 请见附录一 2 权限文件内容 (直接复制到新建.txt文件中，重命名文件为: LICENSE) 1234567891011121314151617181920212223242526272829303132333435363738394041 Copyright (c) 2011-2018 PGTimerDemo Software Foundation (https://github.com/PggMan/PGTimerDemo)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. Spec操作123456789101112/**终端指令*/1.$ pod spec create PGTimer // 本地会生成PGTimer.podspec文件建议用Xcode 打开2.$ pod lib lint // 编辑完podspec文件后需要验证一下这个文件是否可用//#文件不允许有任何的Warning或者Error#3.$ git tag -m\" first release of my testDemo\" \"0.0.1\"$ git push --tags// 打tag podspec文件中需要指定的tag 每次上传新tag 版本 都需要更改spec文件中的tag配置描述 pod账号注册123456789101112131415161718192021/**注册*/$ pod trunk register pg890101@gmail.com 'PggMan' --verbose//1 pg890101@gmail.com 注册的邮箱，会发送信息至此邮箱//2 PggMan 用户名/**查看*/$ pod trunk me // 可以查看你已经注册的信息，其中包含你的name、email、since、Pods、sessions，其中Pods为你往CocoaPods提交的所有的Pod！/**把项目对应的podspec文件推送到Cocoapods服务上去*/$ pod trunk push PGTimer.podspec/**更改已Cocoapods已经经拥有的项目*/$ pod trunk add-owner PGTimer pg890101@gmail.com// CocoapodsDemo 框架名// 添加管理者的邮箱/**更新本地库*/$ pod repo update// 补充 问题1 上传后，pod search PGTimer 搜索不到 1 - 打开 Finder ,然后前往文件夹(快捷键: shift + command + G) ,输入以下地址:~/Library/Caches/CocoaPods/ 2 - 删除 search_index.json 这个文件,这个文件是 pod search 搜索时的缓存文件(本地索引库)。","categories":[],"tags":[]},{"title":"内存管理","slug":"内存管理","date":"2018-07-02T09:43:50.000Z","updated":"2018-07-16T13:32:59.469Z","comments":true,"path":"2018/07/02/内存管理/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/内存管理/","excerpt":"","text":"iOS程序的内存布局 Tagged Point 1 从arm64开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。 2 在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用计数等、NSNumber指针存储的是堆中NSNunber对象的地址值。 3 使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。 4 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据(堆) 5 NSNumber、NSDate、NSString 也会调用objc_msgSend函数，此函数内部对Tagged Point进行了判断。 比如NSNumber的intValue方法，直接从指针中提取数据，节省了以后的调用开销(过程见 Runtime -&gt;objc_msgSend执行流程) Tagged Point判断方法 iOS平台：最高有效位是1 (第64bit) Mac平台: 最低有效位是1 (第0bit) OC对象内存管理 在iOS中，使用引用计数来管理OC对象的内存 一个新创建的OC对象的引用计数+1(1)，当引用计数为0，OC对象就会销毁，释放其占用的内存空间。 调用retain引用计数会+1，调用release会让OC对象的引用计数-1。 内存管理经验 当调用alloc、new、copy、mutableCopy、方法返回了一个对象。在不需要这个对象时，要调用release或者autorelease来释放它 想拥有某个对象，就让它的引用计数+1(retain)；不想再拥有某个对象，就让它的引用计数-1(release) 查看自动释放池 de 函数 私有函数，调用此函数会打印出自动释放池相关信息 1extern void _objc_autoreleasePoolPrint(void); 引用计数存储 isa_t -&gt; uintptr_t has_sidetable_rc 在64bit中，引用计数可以直接存储在优化过得isa指针中，也可能存储在SideTable类中(extra_rc 用19位来存储计数器相关数据,超出后会存储于 has_sidetable_rc结构体内(N - 1)) SideTable结构体中refcnts是一个存放着对象引用计数的散列表。 123456789101112131415161718192021222324252627struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() &#123; memset(&amp;weak_table, 0, sizeof(weak_table)); &#125; ~SideTable() &#123; _objc_fatal(\"Do not delete SideTable.\"); &#125; void lock() &#123; slock.lock(); &#125; void unlock() &#123; slock.unlock(); &#125; void forceReset() &#123; slock.forceReset(); &#125; template&lt;HaveOld, HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;HaveOld, HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);&#125;; 自动释放池 自动释放池的主要底层数据结构是: __AtAutoreleasePool、AutoreleasePoolPage。 调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的。 AutoreleasePoolPage是专属于某一个线程的,结构体内有一个thread属性用来存储它的归属线程。 @autoreleasepool{}的调用与__AtAutoreleasePool有关 12345678910111213141516// OC MRC 代码@autoreleasepool&#123;Person *person = [[Person alloc] init] autorelease];&#125;// 转成c++代码 相当于@autoreleasepool&#123; atautoreleasepoolobj = objc_autoreleasePoolPush(); // 开头调用 Person *person = [[Person alloc] init] autorelease]; objc_autoreleasePoolPop(atautoreleasepoolobj) // 结尾调用&#125; __AtAutoreleasePool的结构体 __AtAutoreleasePool结构体内定义了objc_autoreleasePoolPush()和 objc_autoreleasePoolPop()两个函数。 1234567891011121314151617181920// c++ 结构中可以定义函数struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123; // 构造函数。在创建结构体的时候调用 // atautoreleasepoolobj 是 POOL_BOUNDARY的地址值 atautoreleasepoolobj = objc_autoreleasePoolPush(); &#125; __AtAutoreleasePool() &#123;// 析构函数，在结构体销毁的时候调用 objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; void * atautoreleasepoolobj; &#125;; 123456789101112131415161718192021222324// 1void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;class AutoreleasePoolPage &#123; // 2 static inline void *push() &#123; id *dest; // POOL_BOUNDARY 常量 (Null) 最后返回的是它在page中的内存地址 if (DebugPoolAllocation) &#123; dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest; &#125; AutoreleasePoolPage的结构 自动释放池通过 __AtAutoreleasePool内部定义的函数来操作AutoreleasePoolPage来管理autorelease对象的地址 所有AutoreleasePoolPage对象通过双向链表的形式连接在一起。 每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址 每个AutoreleasePoolPage对象内有固定的7个属性(占56个字节),其余空间(4096 - 56 = 4040 字节)用于存储autorelease对象的内存地址 next指向了下一个能存放autorelease对象地址的区域 自动释放池操作流程结构体 @autoreleasepool @autoreleasepool通过__AtAutoreleasePool来操作，通过AutoreleasePoolPage来管理。 objc_autoreleasePoolPush() objc_autoreleasePoolPush() 是调用了 AutoreleasePoolPage结构体内定义的push()函数，首先，将POOL_BOUNDARY入栈，并返回其存储的内存地址 将N个autorelease对象按顺序存储到page中。 当前page满了，就会新创建一个page，把autorelease对象存储到新的page中。 objc_autoreleasePoolPop() objc_autoreleasePoolPop() 是调用了 AutoreleasePoolPage结构体内定义的pop()函数，调用此函数需要传入objc_autoreleasePoolPush()的返回值(POOL_BOUNDARY的内存地址) pop()会从hotpage（最后一页）的最后一个autorelease对象开始调用他们的release方法，直到遇到传入的内存地址，停止。 Runloop和Autorelease iOS在主线程的Runloop中注册了2个Observer 第一个Observer监听KCFRunLoopEntry事件，会调用objc_autoreleasePoolPush() 第二个Observer: 监听了KCFRunloopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、 objc_autoreleasePoolPush()函数 监听了KCFRunloopBeforeExit事件，会调用objc_autoreleasePoolPop() 属性修饰词 属性 - assign 1 - assign setting方法直接赋值。不会进行引用计数操作。 1@property (nonatomic ,assign) NSInteger age; 属性 - retain 2 - retain setting方法中会判断是不是新值；若是，会release旧值，retain新值 在dealloc中会 release释放对象。 1@property (nonatomic , retain) Dog *dog; 属性 - copy 3 - copy setting方法中会判断是不是新值；若是，会release旧值，copy新值 在dealloc中会 release释放对象 属性不存在 mutableCopy 操作 1@property (nonatomic , copy) NSArray *ary; 属性 - weak 4 - weak 不进行引用计数操作，在其指向对象销毁时，会进行一次清空操作 在setting方法中调用objc_storeWeak函数，会把weak指针在散列表中清除并清空weak指针清空。然后把赋值后的新weak 指针存储到当前OC对象的散列表中(sideTable -&gt; refonts(RefcountMap)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@property (nonatomic , weak) Person *p;/********************** 源码 **********************/idobjc_storeWeak(id *location, id newObj)&#123; return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object *)newObj);&#125;template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123; assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; // 旧得引用计数表, SideTable *newTable;// 操作排序顺序相关(锁) retry: if (haveOld) &#123; oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); if (haveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; &#125; if (haveNew &amp;&amp; newObj) &#123; Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); previouslyInitializedClass = cls; goto retry; &#125; &#125; // 此weak指针存储在引用计数结构体(sideTable)的散列表(refonts)中，将其取出清空 if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // 把新值存储到散列表中 if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; *location = (id)newObj; &#125; else &#123; &#125; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 属性 - strong 5 - strong在setting方法中会对传入的新值进行引用计数操作(retain),降低旧值引用计数(release) 123456789101112131415@property (nonatomic , strong) Person *p;/********************** 源码 **********************/voidobjc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); // retain新值 *location = obj; objc_release(prev); // release旧值&#125; OC指针修饰词 OC指针修饰词 - __strong 超出__strong修饰指针的作用域后才会释放。对引用计数进行了操作(+1) 123456789101112- (void)test &#123; __strong Person *p1; &#123; Person *p = [[Person alloc] init]; p1 = p; &#125; &#125;// p 释放 OC指针修饰词 - __weak __weak只是对其修饰指针指向的对象进行引用，并没有进行引用计数操作。在对象销毁时，会对对其修饰指针进行一次清空操作。 123456789101112- (void)test &#123; __weak Person *p2; &#123; Person *p = [[Person alloc] init]; p2 = p; &#125;// p 释放 &#125; OC指针修饰词 - __unsafe_unretained __unsafe_unretained 同__weak有些类似，只是对其修饰指针指向的对象进行引用，并没有进行引用计数操作.但是,不会对其修饰指针进行清空操作(还指向原来p的内存地址)。 12345678910111213- (void)test &#123; __unsafe_unretained Person *p2; &#123; Person *p = [[Person alloc] init]; p2 = p; &#125;// p 释放 // 此时 p2 仍然指向 p原来的内存地址 &#125; weak实现原理 关于weak的runtime源码 如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 1 - (void)dealloc &#123; _objc_rootDealloc(self);&#125;// 2 void_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125;// 3inline voidobjc_object::rootDealloc()&#123; if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; // 是否是优化过得isa !isa.weakly_referenced &amp;&amp; // 是否 没有 弱引用指向它 !isa.has_assoc &amp;&amp; // 是否 没有 关联对象 !isa.has_cxx_dtor &amp;&amp; // 是否 没有 c++析构函数 !isa.has_sidetable_rc)) // 是否 没有 另一个sidetable结构体存储引用计数相关 &#123; // 直接释放 assert(!sidetable_present()); free(this); &#125; else &#123; // 进行相关处理(释放关联对象、weak指针、sidetable 等) // 进行 4 5 object_dispose((id)this); &#125;&#125;// 4id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125;// 5void *objc_destructInstance(id obj) &#123; if (obj) &#123; bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); if (cxx) object_cxxDestruct(obj); // 销毁c++析构函数(销毁成员变量) if (assoc) _object_remove_assocations(obj); // 销毁关联对象 obj-&gt;clearDeallocating(); // 清空若指针 &#125; return obj;&#125;// 6 inline void objc_object::clearDeallocating()&#123; if (slowpath(!isa.nonpointer)) &#123; // 是普通指针 sidetable_clearDeallocating(); &#125; else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // 是优化过得isa指针 并且有弱引用指针指向它 clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125;// 7 NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); // 引用计数存储表(哈希表) SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; // 用对象的内存地址(this)作为key，去SideTables表里去除若指针进行清空 weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock();&#125; 总结一句话: weak修饰的对象指针指向的对象销毁时，会在该对象的dealloc函数中发送消息(调用函数)。去该对象的引用计数表中对weak指针进行清空操作。 copy与mutableCopy 最简洁的两点 1 改变新值不影响旧值，改变旧值不影响新值 2 copy出来的必是不可变，mutableCopy出来的必是可变","categories":[],"tags":[]}]}