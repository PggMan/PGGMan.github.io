{"meta":{"title":"印度阿三","subtitle":"I'm my own hero","description":"Don't encourage you, you can't do it.","author":"葛朋","url":"http://PGGMan.github.io"},"pages":[],"posts":[{"title":"Runtime","slug":"Runtime","date":"2018-07-03T01:52:06.000Z","updated":"2018-07-07T13:23:24.292Z","comments":true,"path":"2018/07/03/Runtime/","link":"","permalink":"http://PGGMan.github.io/2018/07/03/Runtime/","excerpt":"","text":"Runtime * Objective-C是一门动态性比较强的变成语言，跟C、C++等语言由着很大的不同* Objective-C的动态性是由Runtime API来支撑的* Runtime API提供的借口基本都是C语言的，源码由C\\C++汇编语言编写 isa指针 要想学习Runtime,首先要了解它的底层的一些常用数据结构，比如isa指针 在arm64之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址 从arm64之后，对isa进行了优化，变成了一个共用体(union)结构，还使用位域(: 1 (占用一位))来存 储更多的信息 isa指针结构 12345678910111213141516171819202122/** arm64 架构 */union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t nonpointer : 1; // 是否是优化过的isa指针。0:代表普通指针，存储着Class / Meta-Class对象的内存地址；1: 代表优化过，使用位域和共用体存储更多的信息。 uintptr_t has_assoc : 1; // 是否设置过关联对象。若没有，释放时会更快(release源码中会进行判断，只有好几个条件同时满足才会释放更快) uintptr_t has_cxx_dtor : 1; // 表示该对象是否有 C++ 的析构函数，若没有，释放时会更快.(release源码会判断，只有好几个条件同时满足才会释放更快) uintptr_t shiftcls : 33; // 存储着Class / Meta-Class对象的内存地址信息(相当于普通isa指针的作用) uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被若指针指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在isa中。若为1，那么引用计数会存储在一个叫sideTable的类属性中(内存管理中会提到) uintptr_t extra_rc : 19; // 用19位来存储计数器相关数据,超出后会存储于 has_sidetable_rc结构体内(N - 1) &#125;;&#125; Class 结构图如下 objc_class结构体 Class的底层实现:objc_class 123456struct objc_class &#123; Class isa; // class / Meta-calss 指针 Class superclass; // 父类指针 cache_t cache; // 方法缓存 (哈希表) class_data_bits_t bits; // 用于获取具体的类信息&#125; FAST_DATA_MASK 掩码,objc_class中的bits属性&amp;(于) FAST_DATA_MASK 可以获取到 class_rw_t c结构体 class_rw_t结构体 objc_class -&gt; bits -&gt; data() 存储类 加载完成 后的相关信息。此结构体是类加载的时候创建的(例如 里面的方法列表、属性列表、协议列表，不光存储着当前类的，而且还包括分类的、父类的) 12345678910111213141516171819struct class_rw_t&#123; uint32_t flags; uint32_t version; const class_ro_t *ro; // 存储着类中定义的成员变量、方法、协议等信息(只读) method_list_t * methods; // 方法列表(分类 + (ro -&gt; baseMethodList)) 注意顺序，分类在前 property_list_t * properties; // 属性列表(分类 + (ro -&gt; ivars)) 注意顺序，分类在前 property_list_t * protocols; // 协议列表(分类 + (ro -&gt; baseProtocols)) 注意顺序，分类在前(只读) Class firstSubclass; Class nextSiblingClass; char *demangledName; // 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。&#125; /** firstSubclass 与 nextSiblingClass 在 static inline void foreach_realized_class_and_subclass( Class top, std::function&lt;void (Class)&gt; code) 中用到，此函数是作用是 Enumerates a class and all of its realized subclasses. */ class_ro_t结构体 class_rw_t -&gt; ro 此结构体存储着当前类的相关信息 12345678910111213141516171819202122struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; // 实例对象的内存地址(起点) uint32_t instanceSize; // (instance)实例对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; // 成员变量的布局方式(内存对齐加载到内存和释放的时候都需要用到它来计算区域) const char * name; // 类名 method_list_t * baseMethodList; // 方法列表(当前类中定义的成员变量) protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表(只读) const uint8_t * weakIvarLayout; // 弱成员变量的布局方式(内存对齐，释放对象的时候用来计算释放内存区域的。原来以为是哈希表的掩码，幸亏查了半天资料,最后在苹果开发者文档中找到了相关的资料) property_list_t *baseProperties; // 属性列表(当前类中定义的属性) method_list_t *baseMethods() const &#123; // baseMethodList return baseMethodList; &#125;&#125; method_t结构体 class_rw_t里面的methods、properties、protocols是二维数组，包含了类的初始内容、分类的内容(分类在前)* 分类在前: 编译时，是现将class_ro_t中的信息拷贝过来，然后通过分类信息长度，把数组内容向后移动位置，把分类信息放到前面 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 class_rw_t和class_ro_t中都包含着method_t结构体(方法结构体) 12345struct method_t &#123; SEL name; // 方法名 const char *types; // 编码(返回值类型、参数类型。关注一下@encode指令) IMP imp; // 指向函数的指针 (函数地址)&#125; IMP代表函数的具体实现 SEL代表方法\\函数名，一般叫做选择器,底层结构跟char *类似 可以通过@selector()和sel_registerName(char *)获得 可以通过sel_getName()和NSStringFromSelector()转成字符串 不同类中的相同名字的方法，所对应的选择器是相同的。 types包含了函数返回值，参数编码的字符串 方法查找 方法查找可以分为两部分 1 是有关于方法缓存 2 方法列表及父类查找 方法查找 - 方法缓存 objc_class -&gt; cache Class内部结构中有个方法缓存cache(cache_t),用散列表(哈希表)来缓存曾经调用过得方法，可以提高方法查找的速度 1234567891011121314// cachestruct cache_t &#123; struct bucket_t *_buckets; //散列表 mask_t _mask; // 编码(返回值类型、参数类型。关注一下@encode指令) mask_t _occupied; // 已经缓存的方法数量 &#125; // bucket_tstruct bucket_t &#123; cache_key_t _key; // SEL作为key (_key = SEL &amp; _mask) IMP _imp; // 函数的内存地址 &#125; 当方法/被调用后就会存储到cache散列表中，调用者类中没有会通过superClass指针去父类查找，找到后会存储到调用者的cache散列表中 cache的实现原理是空间换时间，SEL&amp;_mask(掩码)得到角标，直接通过角标去IMP，存储的过程中:发现当前角标下已经有IMP会向上移动当前角标，到最前面后会从尾部继续找，直到找到位置为止。当找不到为止就会放弃当前cache内存空间，从新建立一个哈希表并且扩容。 objc_msgSend执行流程 runtime的源码基本是由C C++ 和汇编实现的，向一些调用频次高(objc_msgSend)是用汇编实现的 源码 ENTRY(宏)入口 12345678910/** objc_msgSend(p,sel_registerName(\"eat\")) 内部实现: （汇编） 1.先判断 p(消息接收者) 是否存在。若不存在直接退出函数调用 2.若receiver(p)存在， 去读取缓存.如果存在就直接调用 3.若缓存中没有函数,会去调用另一个宏，再去查看一下缓存(以防手动添加方法) 4.当这次查缓存也没有找到方法时，去遍历方法列表里面找(如果排好序的二分查找，没有排好序的线性查找),找到方法后边方法填充到缓存 */ 源码如下 流程如下 objc_msgSend动态解析 当objc_msgSend()查找方法失败后，就会来到此步 流程如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/************************ Main.m ************************/#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Student.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; Student *p = [[Student alloc] init]; [p test]; [Student eat]; return 0; &#125;&#125;/*********************** .h *************************/#import \"Person.h\"@interface Student : Person- (void)test;+ (void)eat;@end/************************ .m ************************///// Student.m// RuntimeDemo//// Created by 印度阿三 on 2015/5/27.// Copyright © 2018年 印度阿三. All rights reserved.//#import \"Student.h\"#import &lt;objc/runtime.h&gt;@implementation Student+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //1 判断是否是想要实现的方法 if (sel == sel_registerName(\"test\")) &#123; // 2 创建Method 消息对象 Method method = class_getInstanceMethod(self, @selector(other)); /** 1 被添加方法的类对象 2 添加的方法名 SEL 3 添加的方法地址 IMP 4 添加的方法Types (字符串组成；里面包含返回值类型、参数类型) */ class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method)); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;+ (BOOL)resolveClassMethod:(SEL)sel&#123; // 1判断是否是要实现的类方法 // sel_registerName(\"eat\") 等价于 @selector(@\"eat\") if (sel == sel_registerName(\"eat\")) &#123; // 2创建类方法 Method method = class_getClassMethod(self, sel_registerName(\"classError\")); /** 1 被添加方法的元类对象 |_(注意是 meta-class)_| 2 添加的方法名 SEL 3 添加的方法地址 IMP 4 添加的方法Types (字符串组成；里面包含返回值类型、参数类型) */ class_addMethod(objc_getMetaClass(class_getName(self)), sel, method_getImplementation(method), method_getTypeEncoding(method)); // 标记已经解析 return YES; &#125; // 没有解析 return [super resolveClassMethod:sel];&#125;- (void) other&#123; NSLog(@\"%s\",__func__); &#125;+ (void)classError&#123; NSLog(@\"%s\",__func__);&#125;@end objc_msgSend消息转发 当消息解析失败后会来到此步 流程如下 123456789101112131415161718192021// 备胎方法: 需要返回一个可以处理方法的对象/类对象// 对象方法 走这里 // (对象方法找不到会调用用此方法)- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [[Car alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;// 类方法 走这里// (类方法找不到会盗用此方法)+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"eat\")) &#123; return [[Car alloc] init]; // objc_sendMsg([[Car alloc] init], \"eat\") &#125; // 如果没有返回 return [super forwardingTargetForSelector:aSelector];&#125; 123456789101112131415161718192021222324252627282930313233// 消息签名: 不签名直接调用doesNotRecognizeSelector方法崩溃；实现后会调用forward方法// 对象方法 // 自己实现此方法，(对象方法签名)- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];; &#125; return [super methodSignatureForSelector:aSelector];&#125;// 类方法 // 自己实现此方法，(对象方法签名)+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];; &#125; return [super instanceMethodSignatureForSelector:aSelector];&#125;/**********************************************************************/// 对象方法 走这里- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 里面可以不做操作，但是必须实现此方法， // 若不实现: unrecognized selector sent to instance &#125;// 类方法 走这里+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@\"122342525\"); &#125; Runtime - API12 面试题相关 1 - 讲一下消息转发机制 12 2 - 消息转发机制流程 12 3 - 什么是Runtime? 平时项目中有用过吗 ? OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行。 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 平时编写的OC代码，底层都是转换成了Runtime API进行调用 * 利用关联对象(AssociatedObject)给分类添加属性 * 遍历类的所有成员变量(修改textField的占位文字颜色、字典转模型、自动归档解挡) * 交换方法(实现hook系统方法功能) * 消息转发机制解决方法找不到的异常问题(weak底层实现也是依赖于runtime) * ....... 4 - 下面一段代码打印结果是什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@interface Studenrt : Person- (void) test;@end@implementation Student- (void)test1&#123; NSLog(@\"%@\",[self class]); NSLog(@\"%@\",[super class]);&#125;- (void)test2&#123; BOOL rest1 = [[NSObject class] isKindOfClass:[NSObject class]]; BOOL rest2 = [[NSObject class] isMemberOfClass:[NSObject class]]; BOOL rest3 = [[Person class] isKindOfClass:[Person class]]; BOOL rest4 = [[Person class] isMemberOfClass:[Person class]]; NSLog(@\"%d %d %d %d\",rest1,rest2,rest3,rest4);&#125;@end`/** test1答案: [self class] 通过isa指针找到类对象: Student [super class] 通过isa指针找到类对象: 再通过superClass指针找到父类 person*/``/** test2答案: 打印结果为 1 0 0 0 \"isKindOfClass:\" 用来判断某个对象是否属于某个类，或者是属于某个派生类。\"isMemberOfClass:\" 用来判断某个对象是否为当前类的实例ps： sMemberOfClass不能检测任何的类都是基于NSObject类这一事实， 而isKindOfClass可以。*/5 - 以下代码能不能执行成功？如果可以，打印结果是什么？@interface Studenrt : NSObject@property (nonatomic, copy) NSString *name;- (void)print;@end@implementation Student- (void)print&#123; NSLog(@\"my name's %@\", self.name);&#125;@end/****/@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id cls = [Person class]; void *objc = &amp;cls; [(__bridge id)obj print];&#125;/**答案: 能执行，执行结果是: my name's &lt;ViewController: 0x60c0000e1a00&gt; 原因： */@end 5 - 你了解isa指针吗 1234/** 答: isa指针在arm64之前是存储 Class / Meta-class地址值的指针；之后isa利用到了共用体(union)的数据结构，用64位(8个字节)来存储更多的信息, 其中33位是存储Class / Meta-Class地址信息，其他存储其他一些信息*/ 1 - 讲一下OC的消息机制 1 OC中方法的调用其实都是转成了objc_msgSend函数的调用，给receiver(方法调用者)发送了一条消息(selector方法名) 2 objc_msgSend底层有3大阶段 - 消息发送(当前类、父类中查找) - 动态方法解析 - 消息转发 2 - @dynamic与@synthesize 3 - isKingOfClass 与 isMemeberOfClass的区别 isKindOfClass 会通过superclass指针往上找，判断是否是其或者其子类实例对象 isMemeberOfClass 只通过isa指针只判断当前类对象 4 - super 做了什么, [super classs] 打印结果是什么 1234567891011121314151617181920212223242526272829// super 底层源码struct objc_super&#123; __unsafe_unretained _Nonnull id receiver // 方法接收者 __unsafe_unretained_Nonnull Class super_class // 消息接收者的父类:它的作用是告诉函数找方法时,从父类的方法列表里开始找&#125;- (void)test&#123; [super run]; /** struct objc_super arg = &#123;self, [Person class]&#125;; // Person为suoer的父类类对象 objc_msgSendSuper(arg, sel_registerName(\"run\")); */&#125;/**class底层实现*/- (Class) class:(id)receiver (SEL)__cmd&#123; return object_getClass(\"self\")&#125;/**superclass底层实现*/- (Class) superclass:(id)receiver (SEL)__cmd&#123; return class_getSuperclass(object_getClass(self));&#125; super底层调用了objc_sendSendSuper(,)函数；[super classs]打印结果是 Person(self的父类)，class的底层调用时object_getClass()函数，消息接收者是self.所以会有此结果 super的调用，消息接收者仍然是当前对象，查找方法是从父类开始查找 5 消息转发有什么用途 解决方法找不到的错误，收集错误发送到服务器 解决循环引用问题(利用中间对象，并实现方法转发来解决循环引用问题) 6 消息转发-问题收集 NSProxy 7 - Hook(交换)系统方法 应用场景 hook 按钮点击 hook 设置字体做适配 hook 可变字典数组set方法（防止传nil） hook 按钮 1234567891011121314151617181920212223242526272829303132333435//// UIButton+Hook.m// hookControlDemo//// Created by 印度阿三 on 2018/6/1.// Copyright © 2018年 印度阿三. All rights reserved.// #import \"UIButton+Hook.h\" #import &lt;objc/runtime.h&gt;@implementation UIButton (Hook)+ (void)load&#123; //1.1 获取系统方法(直接从原类的rw_t结构体中的method_array_t里面取) Method method = class_getInstanceMethod(self, sel_registerName(\"sendAction:to:forEvent\")); //1.2 获取分类定义的方法(也会存放到原类的rw_t结构体中method_array_t的数组里面) Method method2 = class_getInstanceMethod(self, @selector(pg_sendAction:to:forEvent:)); // 2 进行交换方法(交换的是rw_t结构体中method_array_t的数组中的method_t中的IMP) // 当调用此方法时会清空缓存 method_exchangeImplementations(method, method2);&#125;// 分类中实现的方法- (void)pg_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123; NSLog(@\"hook\"); /** 调用此方法 相当于调用系统的 sendAction:to:forEvent: 方法 (因为系统的sendAction 与 ps_sendAction的结构体中的IMP已经交换了) */ [self pg_sendAction:action to:target forEvent:event];&#125;@end hook 可变数组 12345678910111213141516171819202122#import \"NSMutableArray+hook.h\"#import &lt;objc/runtime.h&gt;@implementation NSMutableArray (hook)+ (void)load&#123; // 正常情况下load调用一次,但是某些特殊情况下可能调用多次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型 Class cls = NSClassFromString(@\"__NSArrayM\"); Method method = class_getInstanceMethod(cls, @selector(insertObject:atIndex:)); Method method2 = class_getInstanceMethod(cls, @selector(pg_insertObject:atIndex:)); method_exchangeImplementations(method, method2); &#125;);&#125;- (void)pg_insertObject:(id)anObject atIndex:(NSUInteger)index&#123; if (!anObject)return; [self pg_insertObject:anObject atIndex:index];&#125;@end","categories":[],"tags":[]},{"title":"Git","slug":"Git","date":"2018-07-02T11:24:06.000Z","updated":"2018-07-07T13:32:41.821Z","comments":true,"path":"2018/07/02/Git/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/Git/","excerpt":"","text":"1 创建新分支(本地和远程)12345678//1 创建dev_pg分支git branch dev_pg //2 切换到新分支(dev_pg)git checkout dev_pg//3 创建并推送代码到远程分支(dev_pg)git push origin dev_pg 2 删除分支12345//1 删除本地分支(dev_pg)git branch -D dev_pg//2 删除远程分支(dev_pg)git branch -r -D origin/dev_pg 3 查询分支12345678// 1 列出所有分支(本地及远程) -a（all的意思）git branch -a// 2 列出远程分支 -r(remote)git branch -r // 3 列出本地分支 -l(local)git branch -l 4 查询本地git状态1git status 5 合并代码1234567891011121314//1 切换到合并分支 (例如dev分支开发，需要合并到master分支。则先切换到master分支)git checkout master//2 合并代码git merge dev//3 查看是否有冲突git status//4 再次拉一次代码git pull origin master//5 推送到远程git push origin master 6 打标签(tag) 我们常常在代码封板时,使用git 创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的. (1): 轻量级的 它其实是一个独立的分支,或者说是一个不可变的分支.指向特定提交对象的引用. (2):带附注的 实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证,电子邮件地址和日期，一般我们都建议使用含附注型的标签，以便保留相关信息. 1234567891011121314151617181920//1 创建taggit tag -a V1.2 -m &apos;WebSite version 1.2&apos;//2 查看taggit tag//3 查看tag描述内容git tag show V1.2//4 推送的远程git push origin --tags//5 删除本地标签git tag -d V1.2//6 删除远程标签git push origin :refs/tags/V1.2//7 获取远程标签版本下的分支git fetch origin tagV1.2 7 查看分支链接地址12345//1 查看远程分支地址（fetch push）git remote -v//2git remote show origin 8 更改文件夹名字12// 将abc文件夹改名为aaamv abc aaa 9 忽略文件123456789101112131415// 创建忽略文件$ touch .gitignore// 忽略文件内容(找到对应的文件复制内容)NSString *gitignore = @\"https://github.com/github/gitignore\";/** 忽略用户操作信息(文件夹位置调整等) */// 删除用户操作文件 (工程有修改时，使用git status能查到下面的文件 *请见附录1*)$ git rm --cached XXX.xcodeproj/project.xcworkspace/xcuserdata/mac.xcuserdatad/UserInterfaceState.xcuserstate// 提交本地库$ git commit -m \"Removed the stupid strange file that shouldn't be tracked\"// 推送到远程服务$ git push","categories":[],"tags":[]},{"title":"Cocapods","slug":"Cocapods","date":"2018-07-02T09:57:48.000Z","updated":"2018-07-03T02:04:14.020Z","comments":true,"path":"2018/07/02/Cocapods/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/Cocapods/","excerpt":"","text":"1 删除源12 // (sudo是root级别的指令)$ sudo gem sources -r https://rubygems.org/ 2 添加源1$ sudo gem sources -a https://gems.ruby-china.org/ 3 查看源1$ gem sources -l 4 初始化环境1$ sudo gem install cocoapods 5 查看版本1$ pod --version 6 安装(下载)1$ pod setup 框架支持CocoapodsSpec文件1234567891011121314151617181920212223//1 Spec文件配置相关Pod::Spec.new do |s| #s.name = \"PGTimer\" // 框架名称s.version = \"0.0.1\" // 框架版本号s.summary = \"all kinds of categories for iOS develop\" //摘要:简单描述s.description = &lt;&lt;-DESC this project provide all kinds of categories for iOS developerDESC //详细描述s.homepage = \"https://github.com/PggMan/PGTimerDemo\" //项目主路径s.license = \"MIT\" // 开源许可 级别与作用见下图s.author = &#123;&#123; \"PggMan\" =&gt; \"pg890101@gmail.com\" &#125; //作者邮箱名、邮箱地址s.platform = :ios // 框架相关平台s.source = &#123; :git =&gt; \"https://github.com/PggMan/PGTimerDemo.git\", :tag =&gt; s.version &#125; // 下载路径、版本号 注意路径结尾必须添加.git。不然Cocopods不会会报警告\"- WARN | github_sources: Github repositories should end in `.git`.\" 不会通过的s.source_files = \"PGTimerDemo/PGTimer/*.&#123;h,m&#125;\"//被管理文件在项目中的路径s.exclude_files = \"Classes/Exclude\" //需要忽略管理文件夹内的文件s.public_header_files = \"iOS_Category/Classes/UIKit/UI_Categories.h\"，\"iOS_Category/Classes/Foundation/Foundation_Category.h\"，\"iOS_Category/Classes/**/*.h\" // 公开头文件路径s.requires_arc = true // 是否是ARC模式end Spec权限等级 1 请见附录一 2 权限文件内容 (直接复制到新建.txt文件中，重命名文件为: LICENSE) 1234567891011121314151617181920212223242526272829303132333435363738394041 Copyright (c) 2011-2018 PGTimerDemo Software Foundation (https://github.com/PggMan/PGTimerDemo)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. Spec操作123456789101112/**终端指令*/1.$ pod spec create PGTimer // 本地会生成PGTimer.podspec文件建议用Xcode 打开2.$ pod lib lint // 编辑完podspec文件后需要验证一下这个文件是否可用//#文件不允许有任何的Warning或者Error#3.$ git tag -m\" first release of my testDemo\" \"0.0.1\"$ git push --tags// 打tag podspec文件中需要指定的tag 每次上传新tag 版本 都需要更改spec文件中的tag配置描述 pod账号注册123456789101112131415161718192021/**注册*/$ pod trunk register pg890101@gmail.com 'PggMan' --verbose//1 pg890101@gmail.com 注册的邮箱，会发送信息至此邮箱//2 PggMan 用户名/**查看*/$ pod trunk me // 可以查看你已经注册的信息，其中包含你的name、email、since、Pods、sessions，其中Pods为你往CocoaPods提交的所有的Pod！/**把项目对应的podspec文件推送到Cocoapods服务上去*/$ pod trunk push PGTimer.podspec/**更改已Cocoapods已经经拥有的项目*/$ pod trunk add-owner PGTimer pg890101@gmail.com// CocoapodsDemo 框架名// 添加管理者的邮箱/**更新本地库*/$ pod repo update// 补充 问题1 上传后，pod search PGTimer 搜索不到 1 - 打开 Finder ,然后前往文件夹(快捷键: shift + command + G) ,输入以下地址:~/Library/Caches/CocoaPods/ 2 - 删除 search_index.json 这个文件,这个文件是 pod search 搜索时的缓存文件。","categories":[],"tags":[]},{"title":"内存管理","slug":"内存管理","date":"2018-07-02T09:43:50.000Z","updated":"2018-07-02T09:54:16.790Z","comments":true,"path":"2018/07/02/内存管理/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/内存管理/","excerpt":"","text":"12345678910111213141516171819202122232425262728//// NewPerson.h// 内存管理//// Created by 印度阿三 on 2018/7/2.// Copyright © 2018年 印度阿三. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import \"Dog.h\"// 自定义的类 若想实现copy功能需要遵守 NSCopying协议，并实现 copyWithZone:(struct _NSZone *)zone@interface NewPerson : NSObject &lt;NSCopying&gt;//1 assign setting方法直接赋值@property (nonatomic ,assign) NSInteger age;/** 2 retain setting方法中会判断是不是新值；若是，会release旧值，retain新值 在dealloc中会 release释放对象*/@property (nonatomic ,retain) Dog *dog;/** 3 copy setting方法中会判断是不是新值；若是，会release旧值，copy新值 在dealloc中会 release释放对象 属性不存在 mutableCopy 操作*/@property (nonatomic ,copy) NSArray *ary;@property (nonatomic ,weak) Dog *weakDog;@end","categories":[],"tags":[]}]}