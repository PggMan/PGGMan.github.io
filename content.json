{"meta":{"title":"印度阿三","subtitle":"I'm my own hero","description":"Don't encourage you, you can't do it.","author":"葛朋","url":"http://PGGMan.github.io"},"pages":[],"posts":[{"title":"NetWork","slug":"NetWork","date":"2018-09-17T07:51:18.000Z","updated":"2018-09-30T02:55:32.770Z","comments":true,"path":"2018/09/17/NetWork/","link":"","permalink":"http://PGGMan.github.io/2018/09/17/NetWork/","excerpt":"","text":"网络架构 1.1 每个iOS应用都位于某个网络框架栈之上。共4层构成 * 最上层是Cocoa层：包含了用于URL加载的OC API,Web Kit，Bonjour与Game Kit. * 第二层是Core Foundation层，这是一套C API,其中包含了CFNetwork,这是大多数应用级别的网络代码的基础，CFNetwork在CFStream与CFSocket之上提供了一个简单的网络接口，这两个类是针对BSD socket的轻量级封装，后者则形成了最下面的层 Apple建议 1. 建议开发者使用CFNetwork层及其之上的； 2. BSD层的原始socket无法访问系统范围的VPN，也无法激活Wi-Fi和蜂窝无线电，而这些CFNetwork已经帮我们处理好了","categories":[],"tags":[]},{"title":"台式机组装","slug":"myComputer","date":"2018-09-03T08:26:52.000Z","updated":"2018-09-05T07:28:21.802Z","comments":true,"path":"2018/09/03/myComputer/","link":"","permalink":"http://PGGMan.github.io/2018/09/03/myComputer/","excerpt":"","text":"前叙 电脑，在现在来说已经非常普遍了，低到一两千高到几十万。记得自己的第一台电脑是08年高考后，哀求父亲买来的。一四年觉得这台电脑有点跟不上六了。就萌生了用自己的积蓄亲自动手攒一台。从京东和天猫买来了一套自己在百度上搜到的配置单(大概配置是CPU:i5 4570 显卡是拖同学公司内部购买的华硕7800，主板型号不详了，内存条：单挑金士顿8G(早知道涨价这么猛，屯一车了))。我的天，那是一个兴奋啊。然后自己就在那鼓捣鼓捣啊。最后到跑线了，是在不敢下手，买的这么贵的东东，万一弄坏了咋整。最后没办法跑到修电脑那花了200大洋跑线和装系统都搞定了(装得盗版win7)。这台电脑一直配盼着我，从广州回来到北京安稳下来后就直接把它接过来了。无奈最新父亲那边一直想玩QQ象棋。于是乎，只能忍痛割爱了(哈哈😝，我终于有理由换更高配的电脑了)。把电脑邮寄回家没多久，花了8400大洋新买的组装机就到了，结果同事说有款性价比更高的。只好把它推了。花了8700买了一台i7 8700 + 1070ti的机子。不过这台机子声音有点大。而且机箱太小，不是自己喜欢的。自己更喜欢第一台那款海盗船机箱。于是乎又把这台推了。狠下心来，打算多花个几百大洋自己买零件组装。这样不但能买到自己喜欢的零件(有人说这是信仰)还能弥补一下第一次组装主机的遗憾。于是乎最后花了一万三千大洋。没办法。上头啦(ಥ _ ಥ)。 下面是配置图 机箱：美商海盗船(中性机箱，如果安装大于等于2个风扇的前置水冷，需要拆下硬盘架) 主板: 华硕Z370-A(当时和CPU搭着买的，有优惠。这个板子除了价格高点没啥缺点，可超频) CPU: i7-8700k盒装(带k的属于可超频的U，盒装是把散装中性能稍微高的中挑选出来的) 显卡: 七彩虹1080烈焰战神X-8GD5X(现在显卡已经出到了2080Ti,七彩虹相对去其他大牌价格算比较低廉的,自带一键超频。第一次超居然蓝屏了) 内存条: 美商海盗船-复仇者lPX DDR4 3000 16GB(单条，双条8*2 会贵大概一百元) 电源: 美商海盗船RM650x全模组(这个电源品质没的说，就是它的线有点硬) 水冷: 美商海盗船H100i V2一体式水冷CPU散热器(装在这个机箱上需要把硬盘架拆掉，现在机械硬盘还在机箱底部贴着呢。没找到什么好架子固定呢) 固态：英特尔M.2 256G(760P系) 机械：西数蓝盘1T(机械硬盘中黑盘读写数据最快，不过有固态，觉得没必要。自己买条硬盘线，我没有发现哪里带) 组装 组装顺序 将CPU扣到主板CPU槽内,这里没什么说的。有防呆槽，直接按然后卡上金属圈扣。 查内存条，如果是4槽或更多的主板，请间隔插(这里说的一般情况下，最主要的是看插槽颜色，插同色的) 安装CPU水冷排和风扇，因为我这个一体水冷风扇和水冷拍(类似于暖气片子的东东)是用螺丝串行固定的，并且双风扇。并且装在机箱前面(注意风扇可不要装反了啊，一般扇轴带标的朝外，风是往里面吹的)。用长钉穿过机箱孔和风扇孔，然后用胶条把风扇稍微固定一下。两个风扇固定好后，再把冷排贴上去，对齐螺丝孔。拧紧。(用胶条固定是防止上冷排风扇乱动，用完撕下来即可) 接下来将主板安装到机箱内，注意先在主板CPU位背部安装CPU水冷/风冷螺丝框，机箱背部有空隙的，可以固定主板后再安装。固定主板，可先固定右上角螺丝孔，然后右下角螺丝孔，这样其他螺丝孔也固定了。 CPU安装水冷水泵，主要Intel/AMD区别，两颗扣环不一样。 现在开始插线 [我是 1] CPU_FAN/CPU_OPT。两者的区别是，CPU_FAN的宫殿是随着CPU温度而变化得，CPU_OPT是一直全速的。 [我是 2] 电源线插口，显卡位置是直接插到显卡上的。 [我是 3] 是机箱跳线位,机箱线的一组 [我是 4] 机箱音频线位（主机前面的耳机孔）机箱线的一根 安装电源及电源线 插显卡，插完后插电源线 系统盘制作","categories":[],"tags":[]},{"title":"RunLoop","slug":"RunLoop","date":"2018-07-25T12:57:39.000Z","updated":"2018-08-19T07:03:14.410Z","comments":true,"path":"2018/07/25/RunLoop/","link":"","permalink":"http://PGGMan.github.io/2018/07/25/RunLoop/","excerpt":"","text":"Runloop 概念 运行循环，在程序运行过程中循环并处理一些事情 应用场景 定时器(Timer、CADisplayLink) performSelector GCD 事件响应、手势识别、界面刷新 网络请求 AutoreleasePool 线程保活 RunLoop 有无的情况 没有runLoop时。程序启动后就会退出（执行到第7行） 12345678int main(int argc, const char *argv[])&#123; @autoreleasepool&#123; &#125; return 0;&#125; 有runLoop时，程序并不会马上退出，而是保持运行状态。 12345678int main(int argc, const char *argv[])&#123; @autoreleasepool&#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate calss])); &#125; &#125; RunLoop 的基本作用 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能。改做事时做事，该休息时休息 …… RunLoop 对象 iOS中有2套API来访问和使用RunLoop Foundation：NSRunLoop Core Foundation：CFRunLoopRef NSRunLoop和CFRunLoopRef都代表着RunLoop对象 NSRunLoop是基于CFRunLoopRef的一层OC包装 CFRunLoop是开源的(注: 开源框架) RunLoop与线程 每条线程都有唯一的一个预支对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value 线程创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建.(懒加载)* Runloop会在线程结束时销毁 主线程的RunLoop已经自动获取(创建)，子线程默认没有开启RunLoop。 1234567891011121314151617181920// Core Fundation 源码： CFRunLoopGetCurrent()CFRunLoopRef _CFRunLoopGet0b(pthread_t t) &#123; if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; __CFLock(&amp;loopsLock); CFRunLoopRef loop = NULL; // 注意看这里 /** 发现__CFRunLoops不存在时： 就会把传进来先线程p作为key，把创建的RunLoop作为value 存到一个RunLoop管理字典中 */ if (__CFRunLoops) &#123; loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); &#125; __CFUnlock(&amp;loopsLock); return loop;&#125; 获取RunLoop对象 Foundation 12[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获取主线程的RunLoop对象 Core Foundation 123CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 RunLoop的结构及相关类1234567891011121314151617181920212223struct __CFRunLoop &#123; pthread_t _pthread; uint32_t _winthread; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;;","categories":[],"tags":[]},{"title":"音视频","slug":"音视频","date":"2018-07-21T07:06:09.000Z","updated":"2018-09-12T09:05:17.684Z","comments":true,"path":"2018/07/21/音视频/","link":"","permalink":"http://PGGMan.github.io/2018/07/21/音视频/","excerpt":"","text":"音视频 直播 直播流程：采集、处理、编码、推流、流分发、播放。 音视频采集 音视频的采集是直播架构的第一个环节、也是直播的视频来源 采集的来源包括； PC端：屏幕摄像头（摄像头驱动适配） iOS端：摄像头采集（前后摄像头采集） Android端：屏幕摄像头采集（硬件过多，适配一堆坑） 前处理 处理主要包括: 美颜、模糊效果、水印等 各个平台处理方法 PC端：美颜镜头、一些美颜软件 iOS端：图像处理库是GPUImage，提供了丰富的预处理效果，也可利用该库自定义设计 Android端：Google开源的grafika，是一个非常强大的图形处理库 编码 没经过编码的视频非常庞大，存储起来都麻烦，更何况网络传输 编码通过压缩音视频数据来减少体积，方便音视频数据的推流、拉流和存储，能大大提高存储和传输效率 音视频必须经过压缩编码才能进行存储和传输 各个平台处理： iOS端：硬件性能好，可以直接进行硬编码 Android端：硬编码较难，难找到同一的库兼容各个平台（推荐使用软编码） 编码标砖： 视频编码：H.265、H.264、VP8、VP9等 音频编码：AAC（高级音频编码，目的是取代MP3格式）、Opus 传输 从推流端到服务端 数据经过推流端采集和预处理，编码之后推流到服务端 流传输就涉及到相应的传输协议，最常用的协议是RTMP、RTSP、HLS、 流分发 音频流推到服务器后，为了适配各个平台端各种不同协议，需要在服务端做一些流处理工作。比如转码成不同格式支持不同协议如RTMP、HLS、FLV。以适应各个平台。 比如：iOS、Android、PC、网页 播放 拉流获取音视频数据后，需要通过解码器解码，渲染才能在播放器上播放。 总体步骤概览： 解协议：去除网络传输过程中一些无用信息 解封装：获取到的是音频&amp;视频放在一起的封装文件 音视频解码：音视频都是经过压缩编码的内容，解码后才能进行播放 音视频同步：视频&amp;音频文件需要同步播放 音视频播放：声卡&amp;显卡等对音视频进行播放。 采集音视频 音视频采集是直播架构的第一环节，是视频的来源, 框架主要是AVFoundation和CoreMedia,包括视频输出、输入和文件的读写 其实视频的采集有多个应用场景：比如二维码开发、直播 音视频采集包括两部分 视频采集 音频采集 在iOS开发中，是可以同步采集视频&amp;音频的，使用方式也非常简单 相关的采集API都封装在AVFoundation框架中，导入对应框架，实现功能即可 主要API AVCaptureSession：回话 AVCaptureDevice： 设备 AVCaptureDeviceInput: 输入设备 AVCaptureVideoDataOutput：视频输出设备 AVCaptureAudioDataOutput：音频输出设备 AVCaptureConnection：输入与输出桥接 AVAssetWriter：数据写入工具类 AVAssetWriterInput： AVCaptureVideoPreviewLayer：预览视图 AVCaptureSession AVCaptureSession是AVFoundation捕捉类的中心枢纽，在视频捕获时,客户端可以实例化AVCaptureSession并添加适当的AVCaptureInputs、AVCaptureDeviceInput和输出，比如AVCaptureMovieFileOutput。通过[AVCaptureSession startRunning]开始数据流从输入到输出,和[AVCaptureSession stopRunning]停止输出输入的流动。客户端可以通过设置sessionPreset属性定制录制质量水平或输出的分辨率。 12345678910111213- (AVCaptureSession *)addCaptureSession&#123; AVCaptureSession *session = [[AVCaptureSession alloc] init]; /** AVCaptureSessionPresetHigh : [默认值] 高分辨率，会根据当前设备进行自适应 */ session.sessionPreset = AVCaptureSessionPresetHigh; _session = session; return session;&#125; AVCaptureDevice AVCaptureDevice的每个实例对应一个设备，如摄像头或麦克风。AVCaptureDevice的实例不能直接创建。所有现有设备可以使用类方法devicesWithMediaType:defaultDeviceWithMediaType:获取，设备可以提供一个或多个给定流媒体类型。AVCaptureDevice实例可用于提供给AVCaptureSession创建一个为AVCaptureDeviceInput类型的输入源。 1234567891011121314151617181920212223242526272829303132- (AVCaptureDevice *)addCaptureDevice:(AVCaptureSession *)session&#123; //2 创建Device AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if ([device lockForConfiguration:nil]) &#123; //自动闪光灯， if ([device isFlashModeSupported:AVCaptureFlashModeAuto]) &#123; [device setFlashMode:AVCaptureFlashModeAuto]; &#125; // 帧率 1秒10帧 device.activeVideoMinFrameDuration = CMTimeMake(1, 10); //自动白平衡, if ([device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance]) &#123; [device setWhiteBalanceMode:AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance]; &#125; [device unlockForConfiguration]; &#125; /** AVMediaTypeVideo: 摄像头, AVMediaTypeAudio: 话筒, AVMediaTypeMuxed: 弹幕, AVMediaTypeSubtitle: 字幕, AVMediaTypeTimecode */ return device;&#125; AVCaptureDeviceInput AVCaptureDeviceInput 是AVCaptureSession输入源,提供媒体数据从设备连接到系统，通过AVCaptureDevice的实例化得到，就是我们将要用到的设备输出源设备，也就是前后摄像头，通过[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]方法获得。 1234567891011121314- (void)addCaptureDeviceInput:(AVCaptureDevice *)device&#123; //3 创建输入源并添加到回话中 NSError *error; AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if(input) &#123; [_session addInput:input]; &#125; else &#123; NSLog(@\"%@\", error); return; &#125;&#125; AVCaptureMovieFileOutput AVCaptureMovieFileOutput是AVCaptureFileOutput的子类，用来写入QuickTime视频类型的媒体文件。因为这个类在iphone上并不能实现暂停录制，和不能定义视频文件的类型，所以在这里并不使用，而是用灵活性更强的AVCaptureVideoDataOutput和AVCaptureAudioDataOutput来实现视频的录制。 AVCaptureVideoDataOutput AVCaptureVideoDataOutput是AVCaptureOutput一个子类，可以用于用来输出未压缩或压缩的视频捕获的帧，AVCaptureVideoDataOutput产生的实例可以使用其他媒体视频帧适合的api处理，应用程序可以用captureOutput:didOutputSampleBuffer:fromConnection:代理方法来获取帧数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)addCaptureDeviceOutput:(AVCaptureDevice *)device&#123; //4 创建输出源并添加到回话中 //output AVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init]; [_session addOutput:output]; //4.1 设置输出代理 [output setSampleBufferDelegate:self queue:dispatch_queue_create(\"LinXunFengSerialQueue\", DISPATCH_QUEUE_SERIAL)]; //4.2 输出信息设置 // kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange 输出格式和范围 // kCVPixelBufferPixelFormatTypeKey 指定像素输出格式 NSDictionary* setcapSettings = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange], kCVPixelBufferPixelFormatTypeKey, nil]; output.videoSettings = setcapSettings; //4.2 获取输入与输出之间的连接 设置 [self setConnection:output]; &#125;// 代理 获得的是CGImage/** CMSampleBufferRef: 帧缓存数据，描述当前帧信息 获取帧缓存信息 : CMSampleBufferGet CMSampleBufferGetDuration : 获取当前帧播放时间 CMSampleBufferGetImageBuffer : 获取当前帧图片信息 */// CoreImage: 底层绘制图片// 获取帧数据- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; // captureSession 会话如果没有强引用，这里不会得到执行 // 获取图片帧数据 CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); CIImage *ciImage = [CIImage imageWithCVImageBuffer:imageBuffer]; UIImage *image = [UIImage imageWithCIImage:ciImage]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; &#125;);&#125; AVCaptureAudioDataOutput AVCaptureAudioDataOutput是AVCaptureOutput的子类，可用于用来输出捕获来的非压缩或压缩的音频样本，AVCaptureAudioDataOutput产生的实例可以使用其他媒体视频帧适合的api处理，应用程序可以用captureOutput:didOutputSampleBuffer:fromConnection:代理方法来获取音频数据。 123456789- (AVCaptureAudioDataOutput *)audioOutput &#123; if (_audioOutput == nil) &#123; _audioOutput = [[AVCaptureAudioDataOutput alloc] init]; [_audioOutput setSampleBufferDelegate:self queue:self.captureQueue]; &#125; return _audioOutput;&#125;// 代理如上 AVCaptureVideoDataOutput AVCaptureConnection AVCaptureConnection代表AVCaptureInputPort或端口之间的连接，和一个AVCaptureOutput或AVCaptureVideoPreviewLayer在AVCaptureSession中的呈现。 123456789// 注意： 一定要在添加之后 // 获取输入与输出之间的连接 AVCaptureConnection *connection = [output connectionWithMediaType:AVMediaTypeVideo]; // 设置采集数据的方向、镜像 connection.videoOrientation = AVCaptureVideoOrientationPortrait; //connection.videoMirrored = YES; AVCaptureVideoPreviewLayer 是CoreAnimation里面layer的一个子类，用来做为AVCaptureSession预览视频输出，简单来说就是来做为拍摄的视频呈现的一个layer。 12345678910- (AVCaptureVideoPreviewLayer *)previewLayer &#123; if (_previewLayer == nil) &#123; AVCaptureVideoPreviewLayer *preview = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; preview.videoGravity = AVLayerVideoGravityResizeAspectFill; _previewLayer = preview; &#125; return _previewLayer;&#125; AVAssetWriter AVAssetWriter为写入媒体数据到一个新的文件提供服务，AVAssetWriter的实例可以规定写入媒体文件的格式，如QuickTime电影文件格式或MPEG-4文件格式等等。AVAssetWriter有多个并行的轨道媒体数据，基本的有视频轨道和音频轨道，将会在下面介绍。AVAssetWriter的单个实例可用于一次写入一个单一的文件。那些希望写入多次文件的客户端必须每一次用一个新的AVAssetWriter实例。 12345678910111213141516171819202122- (instancetype)initPath:(NSString*)path Height:(NSInteger)cy width:(NSInteger)cx channels:(int)ch samples:(Float64) rate &#123; self = [super init]; if (self) &#123; self.path = path; [[NSFileManager defaultManager] removeItemAtPath:self.path error:nil]; NSURL* url = [NSURL fileURLWithPath:self.path]; _writer = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil]; _writer.shouldOptimizeForNetworkUse = YES; [self initVideoInputHeight:cy width:cx]; if (rate != 0 &amp;&amp; ch != 0) &#123; [self initAudioInputChannels:ch samples:rate]; &#125; &#125; return self;&#125; AVAssetWriterInput 用AVAssetWriterInput去拼接一个多媒体样本类型为CMSampleBuffer(outout代理提供的类型)的实例到AVAssetWriter对象的输出文件的一个轨道；当有多个输入时， AVAssetWriter试图在用于存储和播放效率的理想模式写媒体数据。它的每一个输入信号，是否能接受媒体的数据根据通过readyForMoreMediaData的值来判断。如果readyForMoreMediaData是YES ，说明输入可以接受媒体数据。并且你只能媒体数据追加到输入端。 123456789101112131415161718192021222324252627282930313233- (void)initVideoInputHeight:(NSInteger)cy width:(NSInteger)cx &#123; NSDictionary* settings = [NSDictionary dictionaryWithObjectsAndKeys: AVVideoCodecH264, AVVideoCodecKey, [NSNumber numberWithInteger: cx], AVVideoWidthKey, [NSNumber numberWithInteger: cy], AVVideoHeightKey, nil]; _videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:settings]; _videoInput.expectsMediaDataInRealTime = YES; [_writer addInput:_videoInput];&#125;- (void)initAudioInputChannels:(int)ch samples:(Float64)rate &#123; NSDictionary *settings = [NSDictionary dictionaryWithObjectsAndKeys: [ NSNumber numberWithInt: kAudioFormatMPEG4AAC], AVFormatIDKey, [ NSNumber numberWithInt: ch], AVNumberOfChannelsKey, [ NSNumber numberWithFloat: rate], AVSampleRateKey, [ NSNumber numberWithInt: 128000], AVEncoderBitRateKey, nil]; _audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:settings]; _audioInput.expectsMediaDataInRealTime = YES; [_writer addInput:_audioInput];&#125; 采集步骤 PS：如果做过二维码开发、应该对相关操作非常数据（非常类似） 导入框架 相关API主要在AVFoundation框架中，因此需要先导入框架 创建捕捉回话 (AVCaptureSession) 该回话适用于连接之后的输入源&amp;输出源 输入源：摄像头&amp;话筒 输出源：拿到对应的音频&amp;视频 回话：用于将输入源&amp;输出源连接起来 设置视频输入源&amp;输出源 输入源：（AVCaptureDeviceInput）：从摄像头输入 输出源：(AVCaptureAudioDataOutput）：可以设置代理，在代理方法中拿到数据 将输入&amp;输出添加到回话中 添加预览图层 (AVCaptureVideoPreviewLayer)（可选） 如果希望用户看到采集的画面，可以添加预览图层 该预览图层不是必须的，即使没有添加也可以正常采集数据。 开始采集即可 调用会话（AVCaptureSession）的startRunning方法即可开始采集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192// ViewController.m// VideoDemo//// Created by 印度阿三 on 2018/7/23.// Copyright © 2018年 印度阿三. All rights reserved.//#import \"ViewController.h\"#import &lt;AVFoundation/AVFoundation.h&gt;@interface ViewController ()&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;/** 必须进行强引用*/@property (nonatomic ,strong) AVCaptureSession *session;@property (nonatomic ,weak) AVCaptureVideoPreviewLayer *previewLayer;@property (nonatomic ,weak) UIImageView *imageView;@end@implementation ViewController- (UIImageView *)imageView&#123; if (!_imageView) &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:imageView]; _imageView = imageView; &#125; return _imageView;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; //1 创建回话 AVCaptureSession *session = [self addCaptureSession]; //2 获取音视频设备 AVCaptureDevice *device = [self addCaptureDevice:session]; //3 输入设备 [self addCaptureDeviceInput:device]; //4 输出设备 [self addCaptureDeviceOutput:device]; //start [session startRunning]; &#125;- (AVCaptureSession *)addCaptureSession&#123; AVCaptureSession *session = [[AVCaptureSession alloc] init]; /** AVCaptureSessionPresetHigh : [默认值] 高分辨率，会根据当前设备进行自适应 */ session.sessionPreset = AVCaptureSessionPresetHigh; _session = session; return session;&#125;- (AVCaptureDevice *)addCaptureDevice:(AVCaptureSession *)session&#123; //2 创建Device AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if ([device lockForConfiguration:nil]) &#123; //自动闪光灯， if ([device isFlashModeSupported:AVCaptureFlashModeAuto]) &#123; [device setFlashMode:AVCaptureFlashModeAuto]; &#125; // 帧率 1秒10帧 device.activeVideoMinFrameDuration = CMTimeMake(1, 10); //自动白平衡, if ([device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance]) &#123; [device setWhiteBalanceMode:AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance]; &#125; [device unlockForConfiguration]; &#125; return device;&#125;- (void)addCaptureDeviceInput:(AVCaptureDevice *)device&#123; //3 创建输入源并添加到回话中 NSError *error; AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if(input) &#123; [_session addInput:input]; &#125; else &#123; NSLog(@\"%@\", error); return; &#125;&#125;- (void)addCaptureDeviceOutput:(AVCaptureDevice *)device&#123; //4 创建输出源并添加到回话中 //output AVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init]; [_session addOutput:output]; //4.1 设置输出代理 dispatch_queue_t queue = dispatch_queue_create(\"LinXunFengSerialQueue\", DISPATCH_QUEUE_SERIAL); [output setSampleBufferDelegate:self queue:queue]; //4.2 输出信息设置 // kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange 输出格式和范围 // kCVPixelBufferPixelFormatTypeKey 指定像素输出格式 NSDictionary* setcapSettings = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange], kCVPixelBufferPixelFormatTypeKey, nil]; output.videoSettings = setcapSettings; //4.2 获取输入与输出之间的连接 设置 [self setConnection:output]; &#125;-(void)setConnection:(AVCaptureVideoDataOutput *)output&#123; // 桥接 AVCaptureConnection *connection = [output connectionWithMediaType:AVMediaTypeVideo]; connection.videoOrientation = AVCaptureVideoOrientationPortrait;&#125;- (void)addPreviewLayer&#123; // 预览layer AVCaptureVideoPreviewLayer *previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.session]; [self.view.layer addSublayer:previewLayer]; _previewLayer = previewLayer; &#125;// 代理- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; // captureSession 会话如果没有强引用，这里不会得到执行 // 获取图片帧数据 // 为媒体数据设置一个CMSampleBuffer的Core Video图像缓存对象 CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); UIImage *image; if (@available(iOS 9.0, *)) &#123; CIImage *ciImage = [CIImage imageWithCVImageBuffer:imageBuffer]; image = [UIImage imageWithCIImage:ciImage]; &#125; else &#123; image = [self imageFromSampleBuffer:imageBuffer]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; &#125;);&#125;// iOS9.0 图片处理-(UIImage *)imageFromSampleBuffer:(CVImageBufferRef)imageBuffer&#123; // 锁定pixel buffer的基地址 CVPixelBufferLockBaseAddress(imageBuffer, 0); // 得到pixel buffer的基地址 void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer); // 得到pixel buffer的行字节数 size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer); // 得到pixel buffer的宽和高 size_t width = CVPixelBufferGetWidth(imageBuffer); size_t height = CVPixelBufferGetHeight(imageBuffer); // 创建一个依赖于设备的RGB颜色空间 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); // 用抽样缓存的数据创建一个位图格式的图形上下文（graphics context）对象 CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst); // 根据这个位图context中的像素数据创建一个Quartz image对象 CGImageRef quartzImage = CGBitmapContextCreateImage(context); // 解锁pixel buffer CVPixelBufferUnlockBaseAddress(imageBuffer,0); // 释放context和颜色空间 CGContextRelease(context); CGColorSpaceRelease(colorSpace); // 用Quartz image创建一个UIImage对象image UIImage *image = [UIImage imageWithCGImage:quartzImage scale:1 orientation:UIImageOrientationUp]; // 释放Quartz image对象 CGImageRelease(quartzImage); return (image);&#125;- (void)dealloc&#123; [self.session stopRunning]; self.session = nil;&#125;@end 切换镜头&amp;聚焦&amp;写入音视频切换镜头 切换步骤 给切换过程添加动画 获取当前摄像头是前置还是后置 通过新摄像头（若之前是前置，则此次是后置） 通过新摄像头重新获取设备（AVCaptureDevice） 通过设备(AVCaptureDevice)创建新的输入(AVCaptureDeviceInput) 移除旧input并且添加新Input 注意：修改session配置之前先调用开启修改配置选项，配置完成后，调用提交修改配置项 主要代码123456[session beginConfiguration]; /** 需要修改的配置信息 */[session commitConfiguration]; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; if (self.input) &#123; //1 若当前是前置摄像头，则需新设后摄像头，反之，亦如此。 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; AVCaptureDevicePosition position = (self.input.device.position == AVCaptureDevicePositionFront) ? AVCaptureDevicePositionBack :AVCaptureDevicePositionFront; _curPosition = position; // 获取摄像头设备(前置 或者 后置 依据传入的 AVCaptureDevicePosition 而定) AVCaptureDevice *device = [self cameroWithPosition:position]; NSError *error; AVCaptureDeviceInput *newInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if(newInput) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; CATransition *rotaionAnim = [CATransition animation]; rotaionAnim.type = @\"oglFlip\"; rotaionAnim.subtype = @\"fromLeft\"; rotaionAnim.duration = 0.5; [self.view.layer addAnimation:rotaionAnim forKey:nil]; [self.session beginConfiguration]; // 重设输入源 [self.session removeInput:self.input]; self.input = newInput; [self.session addInput:newInput]; // 重设输出源 [self.session removeOutput:self.output]; [self addCaptureDeviceOutput:device]; [self.session commitConfiguration]; &#125;); &#125; else &#123; NSLog(@\"%@\", error); return; &#125; &#125;); &#125; &#125; 左右成像问题 当使用前置摄像头时，注意左右成像问题。 需要在输出设备(output)的桥接(AVCaptureVideoDataOutput)设置一下镜像映射(照镜子效果) 12345678910111213-(void)setConnection:(AVCaptureVideoDataOutput *)output&#123; // 桥接 AVCaptureConnection *connection = [output connectionWithMediaType:AVMediaTypeVideo]; connection.videoOrientation = AVCaptureVideoOrientationPortrait; // 解决前置摄像头左右成像问题:(当前是前置摄像头 则启动镜子反射效果) if (_curPosition == AVCaptureDevicePositionUnspecified || _curPosition == AVCaptureDevicePositionFront) &#123; connection.videoMirrored = YES; &#125; else &#123; connection.videoMirrored = NO; &#125;&#125; 写入文件美颜滤镜效果GPUImage GPUImage 是一个开源的基于GPU的图片或视频处理框架。其本身内置了多大120多种常见的滤镜效果 GPUImage 是利用GPU，使在图片和视频上应用不同的效果和滤镜变得非常的容易。同时它还拥有出色的性能。并且它的性能要比苹果内置的相关API出色 高斯模糊(毛玻璃)效果 在iOS中实现毛玻璃效果方式有很多 UIToolBar本身有毛玻璃效果 iOS8之后UIEffectView直接创建毛玻璃View 系统CoreImage框架中直接修改图片 GPUImage框架给图片添加一层滤镜 用GPUImage实现毛玻璃效果思路 获取要修改成毛玻璃的图片 给图片添加滤镜 生成新的图片 实现代码12 视频编码iOS硬编码iOS软编码YUV颜色空间流媒体协议推流播放Demo地址：音视频demo","categories":[],"tags":[]},{"title":"设计模式与架构","slug":"设计模式与架构","date":"2018-07-19T00:45:47.000Z","updated":"2018-07-25T11:05:57.142Z","comments":true,"path":"2018/07/19/设计模式与架构/","link":"","permalink":"http://PGGMan.github.io/2018/07/19/设计模式与架构/","excerpt":"","text":"架构架构（Architecture） 软件开发中的设计方案 类似于建造楼房的图纸 类与类之间的关系，模块与模块之间的关系，客户端与服务端的关系 常用架构 MVC、MVP、MVVM、VIPER、CDD 三层架构、四层架构 …… MVCMVC - Apple版 Model与VC和View与VC产生联系，但是Model与View不产生联系。 优点: View与 Model不关联，View重用性强。 缺点: VC代码过于臃肿。 MVC - 变革版 Model与VC和View与VC产生联系，同时View拥有Model。 优点: VC代码不至于过于臃肿。 缺点: View与Model绑定了，耦合性强。重用性弱。 MVP MVP是由View、Model、Presenter组成。核心桥梁就是Presenter。 Presenter负责把Model数据整合成View数据传递给Model；并负责处理View的事件。 优点: 耦合性低、模块职责划分明显、利于分模块测试、View服用率高 缺点: 当View业务逻辑发生变更，可能导致预支关联的所有Presenter都发生改变。 MVVM MVVM与MVP很像，它负责Model和View之间的连接，并处理View的业务逻辑 不同点：View和ViewModel是双向绑定的(互相拥有),并且View会对viewModel进行监听。当ViewModel得值改变，View对应的值也会改变。 监听方式:RAC、KVO、KVOController(faecBook开源框架、github可以找到) 123456789101112- (void)addObserveModelProperty&#123; __weak typeof(self) waekSelf = self; [self.KVOController observe:viewModel keyPath:@\"name\" options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123; waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey]; &#125;]; [self.KVOController observe:viewModel keyPath:@\"image\" options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123; waekSelf.iconView.image = [UIImage imageNamed:change[NSKeyValueChangeNewKey]]; &#125;];&#125; 优点：方便测试、便于代码的移植、兼容MVC 缺点: 类会增多、新人不太易懂。 分层开发 分层开发分为：三层架构、四层架构 三层架构包含：界面层、业务层、数据层(四层架构会把数据层分为网络层、本地数据层) 我们平时说的MVC、MVP、MVVM都属于界面层。 设计模式设计模式(Design Pattern) 是一套呗反复使用、代码设计经验的总结 使用设计模式的好处是：可重用代码，让代码更容易被人理解，保证代码可靠性。 一般与编程语言无关，是一套比较成熟的编程思想 设计模式可以分为三大类 创建型模式：对象实例化的模式，用于解耦对象的实例化过程。 单例模式、工厂方法模式，等等 结构性模式：把类或对象结合在一起形成一个更大的结构 代理模式(不是OC中的传值代理，NSProxy就类似此处的代理模式)、适配器模式、组合模式、装饰模式、等等 行为性模式：类或对象之间如何交互，及划分责任和算法 观察者模式、命令模式、责任链模式、等等 待续","categories":[],"tags":[]},{"title":"GCD","slug":"GCD","date":"2018-07-18T11:11:04.000Z","updated":"2018-10-26T08:35:39.760Z","comments":true,"path":"2018/07/18/GCD/","link":"","permalink":"http://PGGMan.github.io/2018/07/18/GCD/","excerpt":"","text":"GCD并不是线程,GCD是线程的管理工具 GCD的4个概念 同步、异步和并发、串行 1.1 同步：在当前线程中执行任务，不具备开启新线程的能力。 1.2 异步: 在新的线程中执行任务，具备开启线程的能力。 2.1 串行: 一个任务执行完成后，再执行下一个任务 2.2 并发: 多个任务并发(同时)执行 并发与串行队列12345678910111213// global队列 是并发队列dispatch_get_global_queue(0, 0);// main队列 是特殊的串行队列(在主线程中执行)dispatch_get_main_queue(); /**creat队列 当传入 DISPATCH_QUEUE_SERIAL 为串行队列 当传入 DISPATCH_QUEUE_CONCURRENT 为并发队列*/dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL); performSelector 函数 performSelector:withObject: 底层是调用objc_msgSend函数 performSelector:withObject:afterDelay:是向当前线程添加一个定时器，到时间了调用objc_msgSend函数. performSelector:onThread:withObject:waitUntilDone:是向传入线程中添加任务，也涉及到了runLoop相关(当runLoop没有启动时) 面试题相关 面试题 - 1 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; dispatch_queue_t q = dispatch_get_global_queue(0, 0); dispatch_async(q, ^&#123; // 异步并发: 子线程执行 NSLog(@\"1\"); [self performSelector:@selector(test2) withObject:@\"2\" afterDelay:0.0]; [self performSelector:@selector(test2) withObject:@\"2\"]; NSLog(@\"3\"); &#125;); &#125;- (void)test2&#123; NSLog(@\"2\");&#125;// 打印结果：1 3,2没有打印。说明test2没调用。因为子线程默认没有runloop,虽然获取后创建了runloop,但是runloop没有被启动。// [self performSelector:@selector(test2) withObject:@\"2\"]; 无效// GUNstep中可以看到 面试题 - 2 123456789101112131415- (void)test2&#123; NSLog(@\"2\");&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@\"1\"); &#125;]; [self performSelector:@selector(test2) onThread:thread withObject:@\"\" waitUntilDone:YES];&#125;// 打印结果 1，并且崩溃.// 因为thread执行完block后，线程已经退出了。再去执行添加任务会导致崩溃。 队列组的使用 1 dispatch_group_async并发组执行需要用此函数，sync函数是同步的不会开启子线程。 2 dispatch_group_notify 当组内任务执行完后会调用此函数，此函数可以多次实现。 3 dispatch_group_wait(, )当前组内线程暂停，去执行传入组内任务。 1234567891011121314151617181920212223242526272829303132- (void)gcdGroup&#123; //1 创建 并发队列 和 组 dispatch_queue_t global = dispatch_get_global_queue(0, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, global, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; NSLog(@\"%@\",[NSThread currentThread]); &#125; &#125;); dispatch_group_async(group, global, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; NSLog(@\"%@\",[NSThread currentThread]); &#125; &#125;); //2 当1前面执行完后 异步主线程执行 dispatch_queue_t mainQ = dispatch_get_main_queue(); dispatch_group_notify(group, mainQ, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; NSLog(@\"%@\",[NSThread currentThread]); &#125; &#125;); //2 当1前面执行完后 异步子线程执行 dispatch_group_notify(group, global, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; NSLog(@\"%@\",[NSThread currentThread]); &#125; &#125;);&#125; 线程安全 线程安全产生情况: 资源共享 1 一块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源 2 比如多个线程访问一个实例对象，同一个变量、同一份文件 同步锁相关 1 锁的实现 OSSpinLock自旋锁 os_unfair_lock pthread_mutex dispatch_sumphore dispatch_queue(DISPATCH_QUEUE_SERIAL)串行队列 NSLock NSRecursiveock NSCondition条件锁 NSConditionLock条件锁(NSCondition的封装) @synchronized 2 锁的类型 1 自旋锁 2 互斥锁 3 递归锁 4 条件锁 5 信号量 6 串行队列 OSSpinLock 12 -c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/**1 同步与异步1.1 同步：把一个任务添加到某queue后就马上离开。1.2 异步：把一个任务添加到某queue后,等这个任务完成总结：所以,异步调度和同步调度的区别不在于被添加的任务怎样执行,而在于调用线程是否等待任务执行完*/// 同步 - (void) syntFunction&#123;// dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 会死锁 // dispatch_queue_t concurrentQueue =dispatch_get_main_queue(); dispatch_queue_t concurrentQueue = dispatch_queue_create(\"my.concurrent.queue\", DISPATCH_QUEUE_CONCURRENT); NSLog(@\"1\"); dispatch_sync(concurrentQueue, ^()&#123; NSLog(@\"2\"); [NSThread sleepForTimeInterval:10]; NSLog(@\"3\"); &#125;); NSLog(@\"4\");&#125;// 打印结果11:36:25.313 GCDSeTest[544:303] 111:36:25.313 GCDSeTest[544:303] 211:36:30.313 GCDSeTest[544:303] 3//模拟长时间操作11:36:30.314 GCDSeTest[544:303] 4/*********************************分界******************************************/// 异步- (void) asynFunction&#123;// dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// dispatch_queue_t concurrentQueue =dispatch_get_main_queue(); dispatch_queue_t concurrentQueue = dispatch_queue_create(\"my.concurrent.queue\", DISPATCH_QUEUE_CONCURRENT); NSLog(@\"1\"); dispatch_async(concurrentQueue, ^()&#123; NSLog(@\"2\"); [NSThread sleepForTimeInterval:5]; NSLog(@\"3\"); &#125;); NSLog(@\"4\")&#125;// 打印结果 11:42:43.820 GCDSeTest[568:303] 1 11:42:43.820 GCDSeTest[568:303] 4 11:42:43.820 GCDSeTest[568:1003] 2 11:42:48.821 GCDSeTest[568:1003] 3//模拟长时间操作时间 1. 同步与异步-总结： 1 同步(sync) 不管是在主队列(main)、全局队列(global)、生成队列(creat)都是在主线程中就行执行任务，不开启子线程 2 异步(aync) 在全局队列(global)、生成队列(creat)俩种情况下会开启子线程执行任务。但是在主队列(main)中不会开启子线程，在主线程中执行 -c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 /** GCD概念 *//*************************************END*****************************************//**2 GCD - group 2.1 多线程执行任务，全部执行完毕后执行回调方法*/- (void)groupAction&#123; dispatch_queue_t dispatchQueue = dispatch_queue_create(\"ted.queue.next1\", DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; sleep(5); NSLog(@\"任务一完成\"); NSLog(@\"1的线程%@\",[NSThread currentThread]); &#125;); dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; sleep(6); NSLog(@\"任务二完成\"); NSLog(@\"2的线程%@\",[NSThread currentThread]); &#125;); dispatch_group_async(dispatchGroup, globalQueue, ^&#123; sleep(10); NSLog(@\"任务三完成\"); NSLog(@\"3的线程%@\",[NSThread currentThread]); &#125;); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; NSLog(@\"notify：任务都完成了\"); NSLog(@\"4的线程%@\",[NSThread currentThread]); &#125;);&#125;// 打印结果2017-12-19 10:13:53.995774+0800 任务一完成2017-12-19 10:13:53.996010+0800 1的线程&lt;NSThread: 0x60c0004697c0&gt;&#123;number = 3, name = (null)&#125;2017-12-19 10:13:54.991769+0800 任务二完成2017-12-19 10:13:54.991943+0800 2的线程&lt;NSThread: 0x6040000723c0&gt;&#123;number = 4, name = (null)&#125;2017-12-19 10:13:58.996507+0800 任务三完成2017-12-19 10:13:58.996650+0800 3的线程&lt;NSThread: 0x600000077440&gt;&#123;number = 5, name = (null)&#125;2017-12-19 10:13:58.996781+0800 notify：任务都完成了2017-12-19 10:13:58.996874+0800 4的线程&lt;NSThread: 0x6080000688c0&gt;&#123;number = 1, name = main&#125;/***********************************END*******************************************//** GCD -死锁 3.0 必须是在主线程中调用以下方法才会出现死锁 3.1 同步添加主队列回导致死锁 因为同步会等待GCD任务添加完后在执行，而主队列 3.2 队列阻塞，而不是线程阻塞*/- （void）viewDidLoad&#123; [super viewDidLoad]; // 执行死锁 [self deadlock];&#125;- (void)deadlock&#123; NSLog(@\"任务1\"); dispatch_sync(dispatch_get_main_queue(), ^(void)&#123; NSLog(@\"这里死锁了\"); &#125;); NSLog(@\"任务2\"); &#125;// 打印结果2017-12-19 10:36:29.992425+0800 任务1/**总结 1.1 GCD遵循严格的先进先出原则，viewDidLoad是队列头,dispatch_sync函数中的任务排在viewDidLod之后 1.2 主队列是串行队列，并且dispatch_sync是同步添加，会等待dispatch_sync函数中任务执行完后继续往下执行。造成互相等待*//***********************************END*******************************************//** 1 dispatch_queue_create: 2 dispatch_get_global_queue: * 1与2都具备开启子线程的能力 * 2(global) 不需要进行内存管理 * 1（creat）在MRC的环境下需要就行内存管理,用完之后需要手动释放 *//***********************************END*******************************************//** 1 串行与并行是同步或异步操作队列后的执行效果 1.1 串行：按顺序的执行 1.2 并行：多任务一起执行*//***********************************END*******************************************/ GCD什么情况下产生死锁 1调用dispatch_sync往当前串行队列中添加任务 0 - 你理解的多线程？ 1 - iOS的多线程方案有哪几种？你更倾向于哪一种 2 - 你在项目中用到过GCD吗 3 - GCD的队列类型 4 - 说一下OperationQueue 和 GCD区别，以及各自的优势 5 - 线程安全的处理手段有哪些 5.1 - OC你了解的锁有哪些？ 5.2 - 自旋和互斥对比 5.3 - 锁的优先级 5.4 - 用锁实现依赖 5.3 - 使用以上锁需要注意哪些 5.4 - 用C/OC/C++，任选其一，实现自旋或互斥 6 - 编程面试题 7 - 用锁实现线程间的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)test&#123; NSLog(@\"2\"); &#125;// 1- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^&#123; NSLog(@\"1\"); [self performSelector:@selector(test) withObject:nil afterDelay:.0]; NSLog(@\"3\"); &#125;);&#125;po 打印结果是: 1 3 - (void)test&#123; NSLog(@\"2\"); &#125;// 2- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@\"1\"); [self performSelector:@selector(test) withObject:nil afterDelay:.0]; NSLog(@\"3\");&#125; po 打印结果是: 1 3 2 /** performSelector: withObject: afterDelay: 实质是往当前线程添加一个定时器 1 是在子线程中执行，虽然此方法底层获取了当前runLoop，但是没有被启动 2 是在主线程执行，默认有runLoop performSelector: withObject: 实质是给调用 objc_msgSend() 相当于直接调用方法*/ 1234567891011121314151617181920- (void)test&#123; NSLog(@\"2\"); &#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@\"1\"); &#125;]; [thread start]; [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES]; &#125;/** 打印结果是： 1 并且崩溃，因为子线程启动后就结束了。 */ 多线程的安全问题 1 - 资源共享 解决方案 使用线程同步 技术(同步，就是协同步调，按预定的先后次序进行)iOS中的线程同步方案 1 - OSSpinLock 2 - os_unfair_lock 3 - pthread_mutex 4 - dispatch_semaphore 5 - dispatch_queue(DISPATCH_QUEUE_SERIAL) 6 - NSLock 7 - NSRecursiveLock 8 - NSCondition 9 - NSConditionLock A - @synchronized 1 - OSSpinLock 自旋锁，当线程被锁，它会重复检测锁是否打开。高级锁(一直在那等) 内部相当于一个do wile循环一直在检测锁的状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#import \"ViewController.h\"#import &lt;libkern/OSAtomic.h&gt;@interface ViewController ()@property (nonatomic ,assign) NSInteger ticketCount;@property (nonatomic ,assign) NSInteger money;@property (nonatomic ,assign) OSSpinLock lcok;@property (nonatomic ,assign) OSSpinLock lcok1;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 初始化自旋锁 self.lcok = OS_SPINLOCK_INIT; self.lcok1 = OS_SPINLOCK_INIT; &#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self moneyTest]; [self ticketTest]; &#125;#pragma mark - 存取钱- (void)moneyTest&#123; self.money = 300; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 5; i++) &#123; [self saveMoney]; &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 5; i++) &#123; [self drawMoney]; &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 5; i++) &#123; [self saveMoney]; &#125; &#125;); &#125;- (void)saveMoney&#123; OSSpinLockLock(&amp;_lcok1); NSInteger oldmoney = self.money; sleep(0.2); oldmoney += 50; self.money = oldmoney; OSSpinLockUnlock(&amp;_lcok1); NSLog(@\"线程%@--钱数:%ld\",[NSThread currentThread],self.money); &#125;- (void)drawMoney&#123; OSSpinLockLock(&amp;_lcok1); NSInteger oldmoney = self.money; sleep(0.2); oldmoney -= 20; self.money = oldmoney; OSSpinLockUnlock(&amp;_lcok1); NSLog(@\"线程%@--钱数:%ld\",[NSThread currentThread],self.money); &#125;#pragma mark - 卖票- (void)saleTicket&#123; OSSpinLockLock(&amp;_lcok); NSInteger oldTicketCount = self.ticketCount; sleep(0.2); oldTicketCount--; self.ticketCount = oldTicketCount; OSSpinLockUnlock(&amp;_lcok); NSLog(@\"线程%@--票数:%ld\",[NSThread currentThread],self.ticketCount);&#125;- (void)ticketTest&#123; self.ticketCount = 30; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; [self saleTicket]; &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; [self saleTicket]; &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 10; i++) &#123; [self saleTicket]; &#125; &#125;);&#125;@end 时间片轮转调度算法 进程、线程之间的调度都是用的这种算法 线程优先级 当线程优先级高，分配时间片的概率比较高 优先级反转问题 目前OSSpinLock已经不安全 在线程调度的时候，线程是有权重的(优先级) 如果等待锁的线程优先级较高，它会一直占用着CPU的资源，优先级低的线程无法释放锁 自旋锁被阻塞时不是休眠，而是重复循环查看锁的状态忙等 2 - os_unfair_lock os_unfair_lock 用于取代不安全的 OSSpinLock，从iOS10开始支持 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态,非忙等 。它底层也是调用(syscall :系统级指令，直接去睡觉) 低级锁(发现被锁就去休眠) 需要导入头文件#import &lt;os/lock.h&gt; 123456789// 初始化os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;// 尝试加锁os_unfair_lock_trylock(&amp;lock)// 加锁os_unfair_lock_lock(&amp;lock)// 解锁os_unfair_lock_unlock(&amp;lock) 死锁问题 当第一个线程进入并加锁，不进行解锁，其他线程永远阻塞在这里，会导致死锁 2 - pthread_mutex(互斥锁/递归锁) 互斥锁: - 等待锁的线程会处于休眠状态 低级锁(发现被锁就去休眠) 它底层调用(syscall :系统级指令，直接去睡觉) 递归锁: - 允许同一条线程重复加锁 123atommic : (自旋锁)// 给属性加上atomic修饰，可以保证属性的setter和getter都是原子性操作，也就是保证setter和getter内部是线程同步的objc_accessors_mm runtime源码 IO操作(文件操作) 读写安全(多读单写) 同一时间，只有1个线程进行写的操作 同一时间，允许有多个线程进行读的操作 同一时间，不润徐即有写的操作，又有读的操作 pthread_rwlock1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#import \"ViewController.h\"#import &lt;pthread.h&gt;@interface ViewController()@property (nonatomic ,assign) pthread_rwlock_t lock;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 1创建读写锁 pthread_rwlock_init(&amp;(_lock), NULL);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; dispatch_queue_t q = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 10; i ++) &#123; dispatch_async(q, ^&#123; [self read]; &#125;); dispatch_async(q, ^&#123; [self write]; &#125;); &#125;&#125;// 读- (void)read&#123; pthread_rwlock_rdlock(&amp;_lock); NSLog(@\"%s\",__func__); pthread_rwlock_unlock(&amp;_lock);&#125;// 写- (void)write&#123; pthread_rwlock_wrlock(&amp;_lock); sleep(1); NSLog(@\"%s\",__func__); pthread_rwlock_unlock(&amp;_lock);&#125;// 销毁- (void)dealloc&#123; pthread_rwlock_destroy(&amp;_lock); &#125;@end- (void)dealloc&#123; pthread_rwlock_destroy(&amp;_lock); &#125;@end dispatch_barrier_async(异步栅栏) 注意点 这个函数传入的并发队列必须是自己通过dispatch_queue_create创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import \"ViewController.h\"#import &lt;pthread.h&gt;@interface ViewController()@property (nonatomic ,strong) dispatch_queue_t queue;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; for (int i = 0; i &lt; 5; i++) &#123; [self barrarRead]; [self barrarRead]; [self barrarWrite]; [self barrarWrite]; [self barrarRead]; [self barrarWrite]; &#125; &#125;#pragma mark - 栅栏- (void)barrarWrite&#123; dispatch_barrier_async(self.queue, ^&#123; sleep(1); NSLog(@\"%s\",__func__); &#125;); &#125;- (void)barrarRead&#123; dispatch_async(self.queue, ^&#123; sleep(1); NSLog(@\"%s\",__func__); &#125;); &#125;@end GNUstep 没有开源的NS框架，被它开源实现了一遍。","categories":[],"tags":[]},{"title":"逆向环境搭建","slug":"逆向环境搭建","date":"2018-07-15T12:01:02.000Z","updated":"2018-07-15T12:01:02.263Z","comments":true,"path":"2018/07/15/逆向环境搭建/","link":"","permalink":"http://PGGMan.github.io/2018/07/15/逆向环境搭建/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mach-O","slug":"Mach-O","date":"2018-07-15T12:00:13.000Z","updated":"2018-07-15T12:00:13.708Z","comments":true,"path":"2018/07/15/Mach-O/","link":"","permalink":"http://PGGMan.github.io/2018/07/15/Mach-O/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS签名机制","slug":"iOS签名机制","date":"2018-07-15T11:59:46.000Z","updated":"2018-07-15T11:59:46.111Z","comments":true,"path":"2018/07/15/iOS签名机制/","link":"","permalink":"http://PGGMan.github.io/2018/07/15/iOS签名机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"性能优化","slug":"性能优化","date":"2018-07-11T12:36:45.000Z","updated":"2018-07-18T09:23:00.078Z","comments":true,"path":"2018/07/11/性能优化/","link":"","permalink":"http://PGGMan.github.io/2018/07/11/性能优化/","excerpt":"","text":"CPU与GPU 在屏幕成像的过程中，CPU和GPU起着至关重要的作用。 CPU(Central Processing Unit、中央处理器) 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制(Core Graphics) CPU适合计算工作。(取决于处理任务的方式) GPU(Graphics Processing Unit、图形处理器) 纹理的渲染 GPU适合渲染工作。(取决于处理任务的方式) 屏幕展示图片流程 CPU把图形数据计算好，然后GPU渲染后存放于帧缓存中(iOS是双缓存机制。前帧缓存、后帧缓存.当前帧缓存正在工作或者已满，就会在后帧缓存中进行)，由视频控制器部件读取，最后展示在屏幕上。 屏幕成像原理 1 首先，发出垂直同步信号(vSync).绘制一页图像的起点.(每秒60次，也就是间隔时间是16毫秒) 2 然后，从上往下发送水平同步信号(H Sync) 3 当最后一个水平同步信号(HSync)完成，就会开启下一轮回(发送垂直同步信号，绘制下一帧) 卡顿产生的原因 在一帧时间内， CPU和GPU其中一个或者两个工作时间过长，导致垂直同步信号在这一帧内拿不到数据(垂直同步信号由屏幕用硬件时钟产生的信号中的一种),所以就产生了掉帧现象 当CPU和GPU完成后，等待下一次垂直同步信号(VSync)来读取数据。 解决方向: 降低CPU和GPU的工作量。 卡顿优化 CPU 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView。 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性。尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性。不要多次修改属性 AutoLayout会比直接设置frame消耗更多的CPU资源。 图片的size最好刚好跟UIImageView的size保持一致。 控制一下线程的最大并发数量。 尽量把耗时操作放到子线程。 文本处理(尺寸计算、绘制) 图片处理(解码、绘制)(用imageNamed加载的是压缩过得二进制文件，要想在屏幕上显示还需要解码、绘制，默认在主线程进行)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546+ (void)imageName_PG:(NSString *)name forImageView:(UIImageView *)imgView&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //1 获取CGImage CGImageRef cgImage = [UIImage imageNamed:name].CGImage; //2 alphaInfo CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; // 矩阵 if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) &#123; hasAlpha = YES; &#125; //3 bitmapInfo(位映射信息) CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; //4 size size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); //5 context CGContextRef context = CGBitmapContextCreate(NULL, width, height, 0, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo); //6 draw CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // 获得 CGImage cgImage = CGBitmapContextCreateImage(context); UIImage *newImage = [UIImage imageWithCGImage:cgImage]; CGContextRelease(context); CGImageRelease(cgImage); dispatch_async(dispatch_get_main_queue(), ^&#123; imgView.image = newImage; &#125;); &#125;);&#125; GPU 尽量减少视图数量和层次。 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示。 把多张图片合成一张进行渲染。 GPU能处理的最大纹理尺寸是4096 * 4096. 一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 减少透明的视图(alpha &lt; 1),不透明的就设置opaque为YES。 尽量避免出现离屏渲染 离屏渲染 在OpenGL中，GPU有2中渲染方式 On-Screen Rendering: 当前屏幕渲染，在当前用于显示的屏幕缓存区进行渲染操作(帧缓存(前、后)) Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。 Off-Screen Rendering离屏渲染 当渲染比较耗性能或者当前缓存区（前后）已经被占用，就会开启离屏渲染。 离屏渲染本身执行的渲染任务就是比较耗性能的。 需要创建新的缓存区。 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕(On -Screen)切换到离屏（off -Screen）；等到离屏渲染结束以后，将离屛缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屛切换到当前屏幕缓冲区。 触发Off-Screen Rendering离屏渲染 的操作 光栅话：layer.shouldRasterize = YES 遮罩：layer.master = mySublayer 圆角，同时设置裁剪: layer.masksToBounds = YES，layer.cornerRadius大于0. 圆角可以用CoreGraphics绘制裁剪圆角，或者叫美工提供圆角图片 阴影: layer.shadowXXX 如果设置了layer.shadowPath就不会产生离屏渲染。 卡顿检测 平时所说的卡顿 主要是因为在主线程执行了比较耗时的操作 可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的(主要监听RunLoop结束睡眠到执行Source0之间的耗时操作)。 检测工具: 检测Demo耗电来源 CPU处理 Processing ;数据处理计算 网络: Networking :网络请求 定位: Location :用户位置定位 图像: Graphics :图像渲染 耗电优化 尽量降低CPU、GPU功耗 少用定时器 优化I/O操作 尽量不要频繁写入小数据。最好批量一次性写入。 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API，用dispatch_io系统会优化磁盘访问 数据量比较大的，建议使用数据库(比如SQLite CoreData)(数据库怎么优化的？) 网络优化 减少、压缩网络数据(protocol buffer 体积比JSON还小) 上传文件也进行压缩(图片、I/O) 网络请求结果基本一样的可以用缓存(NSMutableURLRequest 然后用NSCache进行缓存) 123NSMutableURLRequestNSCache 尽量使用断点续传 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量下载，减少发送网络请求的数量 定位优化 硬件检测优化 加速剂、陀螺仪、摇晃。会产生动作(motion)事件在不需要检测的场合，应该及时关闭这些硬件 APP的启动 APP的启动可以分为2种 冷启动(Cold Launch): 从零开始启动APP 热启动(Warm Launch): APP已经在内存中，在后台存活着，再次点击图标启动APP APP启动时间的优化，主要是针对冷启动进行优化 通过添加环境变量可以打印出APP的启动时间分析(Edit scheme -&gt; Run -&gt; Arguments(400毫秒以内算正常的) DYLD_PRINT_STATISTICS设置为1(dyld_print_statistics) DYLD_PRINT_STATISTICS_DETAILS设置为1，会展示更加详细的信息 APP的启动过程 APP的冷启动可以概括为3大阶段(注: 需要图) dyld runtime main APP的启动 - dyld dyld (dynamic link editor), Apple的动态链接器，可以用来装载Mach-O文件(可执行文件、动态库等)","categories":[],"tags":[]},{"title":"Block","slug":"Block","date":"2018-07-09T06:09:27.000Z","updated":"2018-07-15T11:48:48.743Z","comments":true,"path":"2018/07/09/Block/","link":"","permalink":"http://PGGMan.github.io/2018/07/09/Block/","excerpt":"","text":"Block block本质上也是一个OC对象，它内部也有一个isa指针 block是封装了函数调用以及函数调用环境的OC对象 block的底层结构如下图所示(OC代码通过clang转成c++代码) xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m 1234567891011121314151617181920212223242526// OC代码 // main.m// GNU//// Created by 印度阿三 on 2018/7/9.// Copyright © 2018年 印度阿三. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int a = 10; NSString *name = @\"abc\"; ^&#123; NSLog(@\"%d--%@\",a,name); &#125;(); return 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// CPP代码/** __main_block_impl_0 -&gt; impl*/struct __block_impl &#123; void *isa; // 说明block是个OC对象 int Flags; int Reserved; // void *FuncPtr; // 存储着 __main_block_func_0函数调用的内存地址 // __main_block_func_0: block内部代码封装成的函数&#125;;/** block 结构体*/struct __main_block_impl_0 &#123; struct __block_impl impl; // 是个结构体变量，不是指针。 struct __main_block_desc_0* Desc; // 捕获的变量 int a; NSString *name; // 构造函数 (类似于OC的init方法)，返回结构体对象（__main_block_impl_0） __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_name, int flags=0) : a(_a), name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;/** block内部代码封装成的函数*/static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy NSString *name = __cself-&gt;name; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_g8_prk3m15j55xgythlcdcnj91c0000gn_T_main_f5d28b_mi_1,a,name); &#125;/** block内部内存管理相关代码*/ static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;name, (void*)src-&gt;name, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;/** block内部内存管理相关代码*/ static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;name, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;/** block 描述信息*/static struct __main_block_desc_0 &#123; size_t reserved; // 该Block升级后所存放的区域，栈block -&gt; 堆block size_t Block_size; // block占用多少内存 void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;/**main函数*/int main(int argc, char * argv[]) &#123; // @autoreleasepool 内存管理中会降到它的作用 /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int a = 10; NSString *name = (NSString *)&amp;__NSConstantStringImpl__var_folders_g8_prk3m15j55xgythlcdcnj91c0000gn_T_main_f5d28b_mi_0; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, name, 570425344))(); return 0; &#125;&#125;/************************* Block结构体的另外一种写法 *************************/struct __main_block_impl_0 &#123; /********** impl ******/ void *isa; int Flags; int Reserved; void *FuncPtr; /********** impl ******/ struct __main_block_desc_0* Desc; int a; NSString *name; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_name, int flags=0) : a(_a), name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;/************** block调用**************/// 第一个参数是block，后面是参数.block -&gt;funPtr(myblock) block调用过程: 当block调用外部局部变量时,会进行变量捕获,通过__main_block_copy_0、__main_block_dispose_0对变量进行内存管理。block内部的代码会封装成__main_block_func_0函数。并存储到__main_block_impl_0(block结构体)中的funPtr中。 Block使用场景 12345678910111213141516171819202122232425262728#import \"Person.h\"@interface Person ()/**block作为属性使用*/// 返回值(^名称)(参数)@property (nonatomic ,copy) void(^myBlock)(void);@end@implementation Person- (void)testTask&#123; // 传递block !self.myBlock?:self.myBlock();&#125;/**block作为函数参数*/// (返回值 (^)(参数)名称)- (void)makeBlockTask:(void (^)(NSString *))callback&#123; /**Tagger Pointer*/ NSString * str = @\"123\"; // 执行block callback(str);&#125;@end Block类型 block分为三种，全局Block、栈Block、堆Block。 iOS程序加载到内存中,由低到高(内存地址). 分为 保留区、_TEXT(代码段)、_DATA(数据段)、heap(堆)、stack(栈)、内核区。 保留区:由于用到了ASLR技术(地址空间布局随机化、iOS4.3开始)。保留区分为偏移区、_PAGEZERO、Header Load commands.内存管理和mach-O文件中会详细说，这里只需要关注_DATA(数据段)、heap(堆)、stack(栈)。 全局Block存放在_DATA(数据段)；栈Block存在在stack(栈)；堆Block存放在heap(堆)。 clang类型 OC类型 存储区域 决定因素(环境) _NSConcreteGlobalBlock _NSGlobalBlock_ 静态数据区 没有访问auto变量 _NSConcreteStackBlock _NSStackBlock_ 栈 访问了auto变量 _NSConcreteMallocBlock _NSMallocBlock_ 堆 _NSStackBlock_调用了copy Block变量捕获(capture) Block变量捕获的目: 为了保证Block内部能够正常访问外部的变量。 说白了就是受外部变量作用域影响 原因： 全局变量，全局都可以访问，不会出现block执行前被释放问题，所以不需要捕获 局部变量 auto，可能block执行前就出了作用域被释放。所以需要变量捕获 局部变量 static，静态变量时存放在_DATA数据段中，不会被释放。但是，指向它的指针会被释放。block会进行指针复制。所以需要变量捕获 代码如下: 全局变量: block结构体内并没有关于全局字符串相关的信息。没有捕获(直接访问) 1234567891011121314151617181920212223242526272829/********************** OC ***********************/NSString *name = @\"abc\";int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; ^&#123; NSLog(@\"%@\",name); &#125;(); return 0; &#125;&#125;/********************** cpp ***********************/// 定义的全局字符串NSString *name = (NSString *)&amp;__NSConstantStringImpl__var_folders_g8_prk3m15j55xgythlcdcnj91c0000gn_T_main_aa8b72_mi_0;// block结构体struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 局部变量 auto: block结构体内生了一个NSString *name字符串。进行了变量捕获(值传递) 12345678910111213141516171819202122232425262728/********************** OC ***********************/int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // 默认前面是有 auto 的 NSString *name = @\"abc\"; ^&#123; NSLog(@\"%@\",name); &#125;(); return 0; &#125;&#125;/********************** cpp ***********************/// 定义的全局字符串struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *name; // 关注这里 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_name, int flags=0) : name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 局部变量 static: block结构体内生了一个NSString *name指向外部static修饰指针所指向的内存地址。进行了变量捕获(指针传递) 12345678910111213141516171819202122232425262728/********************** OC ***********************/int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // 默认前面是有 auto 的 NSString *name = @\"abc\"; ^&#123; NSLog(@\"%@\",name); &#125;(); return 0; &#125;&#125;/********************** cpp ***********************/// 定义的全局字符串struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *name; // 关注这里 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_name, int flags=0) : name(_name) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; Block的copy 三种block进行copy操作的变化(全局、堆、栈) block 的类 存储区域 copy效果 _NSConcreteGlobalBlock 数据段 什么也不做 _NSConcreteStackBlock 栈 从栈到堆 _NSConcreteMallocBlock 堆 引用计数增加 ARC环境下: 编译器会根据情况自动将栈上的block复制到堆上 block作为函数返回值 block被强指针引用 block作为Cocoa API中方法名含有usingBlock的方法参数时 block作为GCD API的方法参数时 block属性建议书写1234567891011/** MRC下，block需要手动copy,属性copy会在seetting方法中对新值进行copy操作*/@property (copy, nonatomic) void(^myBlock)(void);/** ARC下，编译器已经就行了自动copy操作，用copy或strong 来修饰都可以*/@property (copy, nonatomic) void(^myBlock)(void);// 关于属性关键字 请看内存管理 block访问 OC对象类型的auto变量。 全局block_NSConcreteGlobalBlock 方法变量是安全的。因为它存储在数据段，并且它所访问的外部变量也是安全的(非auto。不会有超出作用域的危险)。所以全局block进行copy后自身没变化，也不会对它访问的变量产生影响、 栈blockNSConcreteStackBlock : 栈block是不会对外部变量进行引用计数操作的(强、弱引用)，不管修饰词是（__strong、__weak、__unsafe__unretained）,都是弱引用。 当它进行copy时会调用block内部的copy函数(_Block_object_assign()) _Block_object_assign()函数会根据auto变量的修饰符（__strong、__weak、__unsafe__unretained）做出相应的操作，形成强引用(retain)或者弱引用。 12345678// copy函数static void __main_block_copy_0( struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;name, (void*)src-&gt;name, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125; 堆block _NSConcreteMallocBlock 会对访问的外部对象类型的的auto变量 进行引用计数(强弱引用操作。根据修饰词) Block 与OC对象类型的修饰词 __block __block 可以用于解决block内部无法修改auto变量值得问题(auto变量默认 变量捕获值传递) __block 不能修饰全局变量、静态变量(直接访问、指针传递)。 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Person.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // 修饰基本数据类型auto变量 __block int a = 10; // 修饰OC对象类型auto变量 __block Person *p = [[Person alloc] init]; return 0; &#125;&#125; 12345678910111213141516171819202122232425#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Person.h\"int b = 30; // 定义全局变量int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; //1 修饰静态变量 // 报错: __block attribute not allowed, only allowed on local variables __block static int c = 20; //2 修饰OC对象类型auto变量 NSLog(@\"%p\",&amp;b); __block int b; NSLog(@\"%p\",&amp;b); /** 打印结果: 2018-07-11 21:07:56.717418+0800 BlockDemo[2325:777978] 0x10c3ff1b8 2018-07-11 21:07:56.718018+0800 BlockDemo[2325:777978] 0x7ffee3803088 证明__block修饰的 b 相当于新定义的变量 */ return 0; &#125;&#125; __block实现原理 编译器会将__block变量包装成一个对象 通过观看下面代码，可以看出auto变量被包装成了 __Block_byref_a_0 结构体(结构体名：__Block_byref_变量名_0) 12345678910111213141516171819202122232425262728293031323334/*************************** oc 代码 *****************************/ __block int age = 10;^&#123; NSLog(@\"%d\", age)&#125;();/*************************** cpp 代码 *****************************/ int b = 30; // 定义的全局变量// auto变量 被__block包装成的 结构体struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; // 指向结构体自身的指针 int __flags; int __size; int a; // __block修饰的 auto变量。指向了外部的 &#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // 这里出现了一个 __Block_byref_a_0 类型的结构体指针 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; __Block_byref_a_0内部的auto 变量: 与外部的同名auto变量(此处是变量 int a)指向的内存地址一样。 当block从栈copy到堆时，auto变量也会被拷贝到堆内 __block的内存管理 当block在栈上时，并不会对__block变量产生强引用 应为栈block的生命周期与auto变量的生命周期相同，所以不需要强引用，为__block变量衍生的结构体保命 当block被copy到堆时 会调用block内部的copy函数 copy函数内部会调用_Block_object_assign函数。 _Block_object_assign函数会对__block变量形成强引用(retain) __main_block_copy_0内部会调用__Block_objct_assign函数，此函数(后者)会根据所指向对象的修饰符(__strong、__weak、__unsafe_unretained)做出相应的操作，形成强引用(retain)或者弱引用(注意: 这里仅限于ARC时，MRC时不会自动retain) 当block从堆中移除时 会调用block内部的dispose函数 dispose函数内部会调用__Block_object_dispose函数 _Block_object_dispose函数会自动释放引用的__block变量（release） __block 的__forwarding指针12345678// __block修饰 auto变量a 生成的结构体struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; // forwarding指针 int __flags; int __size; int a; &#125;; 全局block: 不会生成次结构体, 因为全局block是不访问auto变变量产生的，而__Block_byref_a_0只有在__block修饰auto变量时才会产生。两者是矛盾的。 栈block: __forwarding指针指向它的结构体本身。 堆block: 堆block是栈blockcopy了一份放到了堆上。栈block的__forwarding指针指向堆block的 __Block_byref_a_0结构体，而堆block的__forwarding指针指向了它的结构体本身、 block的内存管理函数操作__main_block_copy_0、__main_block_dispose_0123456789101112// retainstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// releasestatic void __main_block_dispose_0(struct __main_block_impl_0*src)&#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; 这两个函数会根据最后一个常量(此处为 8)决定对传入的变量(此处为 a)怎样进行内存管理(此处是 __block变量) 对象 – BLOCK_FIELD_IS_OBJECT (3) __block 变量 – BLOCK_FIELD_IS_BYREF (8) __weak __weak可以用于解决block循环引用问题(用来修饰OC对象，修饰基本数据类型会报警告) 用法如下 1__weak typeof(self) weakSelf = self; __weak修饰的OC变量在block结构体内会有__weak标记。在调用__main_block_copy_0、__main_block_dispose_0函数时，虽然传入的常量也是3(BLOCK_FIELD_IS_OBJECT)。但是他们对标记为__weak的OC对象不会进行引用计数操作(强引用) __strong __strong的作用是确保block内其所修饰的OC对象不会被释放。在调用__main_block_copy_0、__main_block_dispose_0函数时，会对其修饰的对象进行引用计数相关的操作。 用法如下:12345678910111213141516int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; Person *P = [[Person alloc] init]; __weak typeof(P) weakP = P; void (^myBlock)(void) = ^&#123; __strong typeof(P) strongP = weakP; NSLog(@\"%@\",strongP.name); &#125;; myBlock(); return 0; &#125;&#125;","categories":[],"tags":[]},{"title":"Runtime","slug":"Runtime","date":"2018-07-03T01:52:06.000Z","updated":"2018-07-10T02:13:15.874Z","comments":true,"path":"2018/07/03/Runtime/","link":"","permalink":"http://PGGMan.github.io/2018/07/03/Runtime/","excerpt":"","text":"Runtime Objective-C是一门动态性比较强的变成语言，跟C、C++等语言由着很大的不同 Objective-C的动态性是由Runtime API来支撑的 Runtime API提供的借口基本都是C语言的，源码由C\\C++汇编语言编写 isa指针 要想学习Runtime,首先要了解它的底层的一些常用数据结构，比如isa指针 在arm64之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址 从arm64之后，对isa进行了优化，变成了一个共用体(union)结构，还使用位域(: 1 (占用一位))来存 储更多的信息 isa指针结构 12345678910111213141516171819202122/** arm64 架构 */union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t nonpointer : 1; // 是否是优化过的isa指针。0:代表普通指针，存储着Class / Meta-Class对象的内存地址；1: 代表优化过，使用位域和共用体存储更多的信息。 uintptr_t has_assoc : 1; // 是否设置过关联对象。若没有，释放时会更快(release源码中会进行判断，只有好几个条件同时满足才会释放更快) uintptr_t has_cxx_dtor : 1; // 表示该对象是否有 C++ 的析构函数，若没有，释放时会更快.(release源码会判断，只有好几个条件同时满足才会释放更快) uintptr_t shiftcls : 33; // 存储着Class / Meta-Class对象的内存地址信息(相当于普通isa指针的作用) uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被若指针指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在isa中。若为1，那么引用计数会存储在一个叫sideTable的类属性中(内存管理中会提到) uintptr_t extra_rc : 19; // 用19位来存储计数器相关数据,超出后会存储于 has_sidetable_rc结构体内(N - 1) &#125;;&#125; Class 结构图如下 objc_class结构体 Class的底层实现:objc_class 123456struct objc_class &#123; Class isa; // class / Meta-calss 指针 Class superclass; // 父类指针 cache_t cache; // 方法缓存 (哈希表) class_data_bits_t bits; // 用于获取具体的类信息&#125; FAST_DATA_MASK 掩码,objc_class中的bits属性&amp;(于) FAST_DATA_MASK 可以获取到 class_rw_t c结构体 class_rw_t结构体 objc_class -&gt; bits -&gt; data() 存储类 加载完成 后的相关信息。此结构体是类加载的时候创建的(例如 里面的方法列表、属性列表、协议列表，不光存储着当前类的，而且还包括分类的、父类的) 12345678910111213141516171819struct class_rw_t&#123; uint32_t flags; uint32_t version; const class_ro_t *ro; // 存储着类中定义的成员变量、方法、协议等信息(只读) method_list_t * methods; // 方法列表(分类 + (ro -&gt; baseMethodList)) 注意顺序，分类在前 property_list_t * properties; // 属性列表(分类 + (ro -&gt; ivars)) 注意顺序，分类在前 property_list_t * protocols; // 协议列表(分类 + (ro -&gt; baseProtocols)) 注意顺序，分类在前(只读) Class firstSubclass; Class nextSiblingClass; char *demangledName; // 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。&#125; /** firstSubclass 与 nextSiblingClass 在 static inline void foreach_realized_class_and_subclass( Class top, std::function&lt;void (Class)&gt; code) 中用到，此函数是作用是 Enumerates a class and all of its realized subclasses. */ class_ro_t结构体 class_rw_t -&gt; ro 此结构体存储着当前类的相关信息 12345678910111213141516171819202122struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; // 实例对象的内存地址(起点) uint32_t instanceSize; // (instance)实例对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; // 成员变量的布局方式(内存对齐加载到内存和释放的时候都需要用到它来计算区域) const char * name; // 类名 method_list_t * baseMethodList; // 方法列表(当前类中定义的成员变量) protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表(只读) const uint8_t * weakIvarLayout; // 弱成员变量的布局方式(内存对齐，释放对象的时候用来计算释放内存区域的。原来以为是哈希表的掩码，幸亏查了半天资料,最后在苹果开发者文档中找到了相关的资料) property_list_t *baseProperties; // 属性列表(当前类中定义的属性) method_list_t *baseMethods() const &#123; // baseMethodList return baseMethodList; &#125;&#125; method_t结构体 class_rw_t里面的methods、properties、protocols是二维数组，包含了类的初始内容、分类的内容(分类在前)* 分类在前: 编译时，是现将class_ro_t中的信息拷贝过来，然后通过分类信息长度，把数组内容向后移动位置，把分类信息放到前面 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 class_rw_t和class_ro_t中都包含着method_t结构体(方法结构体) 12345struct method_t &#123; SEL name; // 方法名 const char *types; // 编码(返回值类型、参数类型。关注一下@encode指令) IMP imp; // 指向函数的指针 (函数地址)&#125; IMP代表函数的具体实现 SEL代表方法\\函数名，一般叫做选择器,底层结构跟char *类似 可以通过@selector()和sel_registerName(char *)获得 可以通过sel_getName()和NSStringFromSelector()转成字符串 不同类中的相同名字的方法，所对应的选择器是相同的。 types包含了函数返回值，参数编码的字符串 方法查找 方法查找可以分为两部分 1 是有关于方法缓存 2 方法列表及父类查找 方法缓存 objc_class -&gt; cache Class内部结构中有个方法缓存cache(cache_t),用散列表(哈希表)来缓存曾经调用过得方法，可以提高方法查找的速度 1234567891011121314// cachestruct cache_t &#123; struct bucket_t *_buckets; //散列表 mask_t _mask; // 编码(返回值类型、参数类型。关注一下@encode指令) mask_t _occupied; // 已经缓存的方法数量 &#125; // bucket_tstruct bucket_t &#123; cache_key_t _key; // SEL作为key (_key = SEL &amp; _mask) IMP _imp; // 函数的内存地址 &#125; 当方法/被调用后就会存储到cache散列表中，调用者类中没有会通过superClass指针去父类查找，找到后会存储到调用者的cache散列表中 cache的实现原理是空间换时间，SEL&amp;_mask(掩码)得到角标，直接通过角标去IMP，存储的过程中:发现当前角标下已经有IMP会向上移动当前角标，到最前面后会从尾部继续找，直到找到位置为止。当找不到为止就会放弃当前cache内存空间，从新建立一个哈希表并且扩容。 objc_msgSend执行流程 runtime的源码基本是由C C++ 和汇编实现的，向一些调用频次高(objc_msgSend)是用汇编实现的 源码 ENTRY(宏)入口 12345678910/** objc_msgSend(p,sel_registerName(\"eat\")) 内部实现: （汇编） 1.先判断 p(消息接收者) 是否存在。若不存在直接退出函数调用 2.若receiver(p)存在， 去读取缓存.如果存在就直接调用 3.若缓存中没有函数,会去调用另一个宏，再去查看一下缓存(以防手动添加方法) 4.当这次查缓存也没有找到方法时，去遍历方法列表里面找(如果排好序的二分查找，没有排好序的线性查找),找到方法后边方法填充到缓存 */ 源码如下 流程如下 objc_msgSend动态解析 当objc_msgSend()查找方法失败后，就会来到此步 流程如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/************************ Main.m ************************/#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#import \"Student.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; Student *p = [[Student alloc] init]; [p test]; [Student eat]; return 0; &#125;&#125;/*********************** .h *************************/#import \"Person.h\"@interface Student : Person- (void)test;+ (void)eat;@end/************************ .m ************************///// Student.m// RuntimeDemo//// Created by 印度阿三 on 2015/5/27.// Copyright © 2018年 印度阿三. All rights reserved.//#import \"Student.h\"#import &lt;objc/runtime.h&gt;@implementation Student+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //1 判断是否是想要实现的方法 if (sel == sel_registerName(\"test\")) &#123; // 2 创建Method 消息对象 Method method = class_getInstanceMethod(self, @selector(other)); /** 1 被添加方法的类对象 2 添加的方法名 SEL 3 添加的方法地址 IMP 4 添加的方法Types (字符串组成；里面包含返回值类型、参数类型) */ class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method)); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;+ (BOOL)resolveClassMethod:(SEL)sel&#123; // 1判断是否是要实现的类方法 // sel_registerName(\"eat\") 等价于 @selector(@\"eat\") if (sel == sel_registerName(\"eat\")) &#123; // 2创建类方法 Method method = class_getClassMethod(self, sel_registerName(\"classError\")); /** 1 被添加方法的元类对象 |_(注意是 meta-class)_| 2 添加的方法名 SEL 3 添加的方法地址 IMP 4 添加的方法Types (字符串组成；里面包含返回值类型、参数类型) */ class_addMethod(objc_getMetaClass(class_getName(self)), sel, method_getImplementation(method), method_getTypeEncoding(method)); // 标记已经解析 return YES; &#125; // 没有解析 return [super resolveClassMethod:sel];&#125;- (void) other&#123; NSLog(@\"%s\",__func__); &#125;+ (void)classError&#123; NSLog(@\"%s\",__func__);&#125;@end objc_msgSend消息转发 当消息解析失败后会来到此步 流程如下 123456789101112131415161718192021// 备胎方法: 需要返回一个可以处理方法的对象/类对象// 对象方法 走这里 // (对象方法找不到会调用用此方法)- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [[Car alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;// 类方法 走这里// (类方法找不到会盗用此方法)+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"eat\")) &#123; return [[Car alloc] init]; // objc_sendMsg([[Car alloc] init], \"eat\") &#125; // 如果没有返回 return [super forwardingTargetForSelector:aSelector];&#125; 123456789101112131415161718192021222324252627282930313233// 消息签名: 不签名直接调用doesNotRecognizeSelector方法崩溃；实现后会调用forward方法// 对象方法 // 自己实现此方法，(对象方法签名)- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];; &#125; return [super methodSignatureForSelector:aSelector];&#125;// 类方法 // 自己实现此方法，(对象方法签名)+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == sel_registerName(\"test\")) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];; &#125; return [super instanceMethodSignatureForSelector:aSelector];&#125;/**********************************************************************/// 对象方法 走这里- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 里面可以不做操作，但是必须实现此方法， // 若不实现: unrecognized selector sent to instance &#125;// 类方法 走这里+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@\"122342525\"); &#125; Runtime - API12 面试题相关 1 - 讲一下消息转发机制 12 2 - 消息转发机制流程 12 3 - 什么是Runtime? 平时项目中有用过吗 ? OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行。 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 平时编写的OC代码，底层都是转换成了Runtime API进行调用 * 利用关联对象(AssociatedObject)给分类添加属性 * 遍历类的所有成员变量(修改textField的占位文字颜色、字典转模型、自动归档解挡) * 交换方法(实现hook系统方法功能) * 消息转发机制解决方法找不到的异常问题(weak底层实现也是依赖于runtime) * ....... 4 - 下面一段代码打印结果是什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@interface Studenrt : Person- (void) test;@end@implementation Student- (void)test1&#123; NSLog(@\"%@\",[self class]); NSLog(@\"%@\",[super class]);&#125;- (void)test2&#123; BOOL rest1 = [[NSObject class] isKindOfClass:[NSObject class]]; BOOL rest2 = [[NSObject class] isMemberOfClass:[NSObject class]]; BOOL rest3 = [[Person class] isKindOfClass:[Person class]]; BOOL rest4 = [[Person class] isMemberOfClass:[Person class]]; NSLog(@\"%d %d %d %d\",rest1,rest2,rest3,rest4);&#125;@end`/** test1答案: [self class] 通过isa指针找到类对象: Student [super class] 通过isa指针找到类对象: 再通过superClass指针找到父类 person*/``/** test2答案: 打印结果为 1 0 0 0 \"isKindOfClass:\" 用来判断某个对象是否属于某个类，或者是属于某个派生类。\"isMemberOfClass:\" 用来判断某个对象是否为当前类的实例ps： sMemberOfClass不能检测任何的类都是基于NSObject类这一事实， 而isKindOfClass可以。*/5 - 以下代码能不能执行成功？如果可以，打印结果是什么？@interface Studenrt : NSObject@property (nonatomic, copy) NSString *name;- (void)print;@end@implementation Student- (void)print&#123; NSLog(@\"my name's %@\", self.name);&#125;@end/****/@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id cls = [Person class]; void *objc = &amp;cls; [(__bridge id)obj print];&#125;/**答案: 能执行，执行结果是: my name's &lt;ViewController: 0x60c0000e1a00&gt; 原因： */@end 5 - 你了解isa指针吗 1234/** 答: isa指针在arm64之前是存储 Class / Meta-class地址值的指针；之后isa利用到了共用体(union)的数据结构，用64位(8个字节)来存储更多的信息, 其中33位是存储Class / Meta-Class地址信息，其他存储其他一些信息*/ 1 - 讲一下OC的消息机制 1 OC中方法的调用其实都是转成了objc_msgSend函数的调用，给receiver(方法调用者)发送了一条消息(selector方法名) 2 objc_msgSend底层有3大阶段 - 消息发送(当前类、父类中查找) - 动态方法解析 - 消息转发 2 - @dynamic与@synthesize 3 - isKingOfClass 与 isMemeberOfClass的区别 isKindOfClass 会通过superclass指针往上找，判断是否是其或者其子类实例对象 isMemeberOfClass 只通过isa指针只判断当前类对象 4 - super 做了什么, [super classs] 打印结果是什么 1234567891011121314151617181920212223242526272829// super 底层源码struct objc_super&#123; __unsafe_unretained _Nonnull id receiver // 方法接收者 __unsafe_unretained_Nonnull Class super_class // 消息接收者的父类:它的作用是告诉函数找方法时,从父类的方法列表里开始找&#125;- (void)test&#123; [super run]; /** struct objc_super arg = &#123;self, [Person class]&#125;; // Person为suoer的父类类对象 objc_msgSendSuper(arg, sel_registerName(\"run\")); */&#125;/**class底层实现*/- (Class) class:(id)receiver (SEL)__cmd&#123; return object_getClass(\"self\")&#125;/**superclass底层实现*/- (Class) superclass:(id)receiver (SEL)__cmd&#123; return class_getSuperclass(object_getClass(self));&#125; super底层调用了objc_sendSendSuper(,)函数；[super classs]打印结果是 Person(self的父类)，class的底层调用时object_getClass()函数，消息接收者是self.所以会有此结果 super的调用，消息接收者仍然是当前对象，查找方法是从父类开始查找 5 消息转发有什么用途 解决方法找不到的错误，收集错误发送到服务器 解决循环引用问题(利用中间对象，并实现方法转发来解决循环引用问题) 6 消息转发-问题收集 NSProxy 7 - Hook(交换)系统方法 应用场景 hook 按钮点击 hook 设置字体做适配 hook 可变字典数组set方法（防止传nil） hook 按钮 1234567891011121314151617181920212223242526272829303132333435//// UIButton+Hook.m// hookControlDemo//// Created by 印度阿三 on 2018/6/1.// Copyright © 2018年 印度阿三. All rights reserved.// #import \"UIButton+Hook.h\" #import &lt;objc/runtime.h&gt;@implementation UIButton (Hook)+ (void)load&#123; //1.1 获取系统方法(直接从原类的rw_t结构体中的method_array_t里面取) Method method = class_getInstanceMethod(self, sel_registerName(\"sendAction:to:forEvent\")); //1.2 获取分类定义的方法(也会存放到原类的rw_t结构体中method_array_t的数组里面) Method method2 = class_getInstanceMethod(self, @selector(pg_sendAction:to:forEvent:)); // 2 进行交换方法(交换的是rw_t结构体中method_array_t的数组中的method_t中的IMP) // 当调用此方法时会清空缓存 method_exchangeImplementations(method, method2);&#125;// 分类中实现的方法- (void)pg_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123; NSLog(@\"hook\"); /** 调用此方法 相当于调用系统的 sendAction:to:forEvent: 方法 (因为系统的sendAction 与 ps_sendAction的结构体中的IMP已经交换了) */ [self pg_sendAction:action to:target forEvent:event];&#125;@end hook 可变数组 12345678910111213141516171819202122#import \"NSMutableArray+hook.h\"#import &lt;objc/runtime.h&gt;@implementation NSMutableArray (hook)+ (void)load&#123; // 正常情况下load调用一次,但是某些特殊情况下可能调用多次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型 Class cls = NSClassFromString(@\"__NSArrayM\"); Method method = class_getInstanceMethod(cls, @selector(insertObject:atIndex:)); Method method2 = class_getInstanceMethod(cls, @selector(pg_insertObject:atIndex:)); method_exchangeImplementations(method, method2); &#125;);&#125;- (void)pg_insertObject:(id)anObject atIndex:(NSUInteger)index&#123; if (!anObject)return; [self pg_insertObject:anObject atIndex:index];&#125;@end","categories":[],"tags":[]},{"title":"Git","slug":"Git","date":"2018-07-02T11:24:06.000Z","updated":"2018-07-07T13:46:53.777Z","comments":true,"path":"2018/07/02/Git/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/Git/","excerpt":"","text":"1 创建新分支(本地和远程)12345678//1 创建dev_pg分支git branch dev_pg //2 切换到新分支(dev_pg)git checkout dev_pg//3 创建并推送代码到远程分支(dev_pg)git push origin dev_pg 2 删除分支12345//1 删除本地分支(dev_pg)git branch -D dev_pg//2 删除远程分支(dev_pg)git branch -r -D origin/dev_pg 3 查询分支12345678// 1 列出所有分支(本地及远程) -a（all的意思）git branch -a// 2 列出远程分支 -r(remote)git branch -r // 3 列出本地分支 -l(local)git branch -l 4 查询本地git状态1git status 5 合并代码1234567891011121314//1 切换到合并分支 (例如dev分支开发，需要合并到master分支。则先切换到master分支)git checkout master//2 合并代码git merge dev//3 查看是否有冲突git status//4 再次拉一次代码git pull origin master//5 推送到远程git push origin master 6 打标签(tag) 我们常常在代码封板时,使用git 创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的. (1): 轻量级的 它其实是一个独立的分支,或者说是一个不可变的分支.指向特定提交对象的引用. (2):带附注的 实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证,电子邮件地址和日期，一般我们都建议使用含附注型的标签，以便保留相关信息. 1234567891011121314151617181920//1 创建taggit tag -a V1.2 -m &apos;WebSite version 1.2&apos;//2 查看taggit tag//3 查看tag描述内容git tag show V1.2//4 推送的远程git push origin --tags//5 删除本地标签git tag -d V1.2//6 删除远程标签git push origin :refs/tags/V1.2//7 获取远程标签版本下的分支git fetch origin tagV1.2 7 查看分支链接地址12345//1 查看远程分支地址（fetch push）git remote -v//2git remote show origin 8 更改文件夹名字12// 将abc文件夹改名为aaamv abc aaa 9 忽略文件123456789101112131415// 创建忽略文件$ touch .gitignore// 忽略文件内容(找到对应的文件复制内容)NSString *gitignore = @\"https://github.com/github/gitignore\";/** 忽略用户操作信息(文件夹位置调整等) */// 删除用户操作文件 (工程有修改时，使用git status能查到下面的文件 *请见附录1*)$ git rm --cached XXX.xcodeproj/project.xcworkspace/xcuserdata/mac.xcuserdatad/UserInterfaceState.xcuserstate// 提交本地库$ git commit -m \"Removed the stupid strange file that shouldn't be tracked\"// 推送到远程服务$ git push","categories":[],"tags":[]},{"title":"Cocapods","slug":"Cocapods","date":"2018-07-02T09:57:48.000Z","updated":"2018-07-09T05:52:15.831Z","comments":true,"path":"2018/07/02/Cocapods/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/Cocapods/","excerpt":"","text":"1 删除源12 // (sudo是root级别的指令)$ sudo gem sources -r https://rubygems.org/ 2 添加源1$ sudo gem sources -a https://gems.ruby-china.org/ 3 查看源1$ gem sources -l 4 初始化环境1$ sudo gem install cocoapods 5 查看版本1$ pod --version 6 安装(下载)1$ pod setup 框架支持CocoapodsSpec文件1234567891011121314151617181920212223//1 Spec文件配置相关Pod::Spec.new do |s| #s.name = \"PGTimer\" // 框架名称s.version = \"0.0.1\" // 框架版本号s.summary = \"all kinds of categories for iOS develop\" //摘要:简单描述s.description = &lt;&lt;-DESC this project provide all kinds of categories for iOS developerDESC //详细描述s.homepage = \"https://github.com/PggMan/PGTimerDemo\" //项目主路径s.license = \"MIT\" // 开源许可 级别与作用见下图s.author = &#123;&#123; \"PggMan\" =&gt; \"pg890101@gmail.com\" &#125; //作者邮箱名、邮箱地址s.platform = :ios // 框架相关平台s.source = &#123; :git =&gt; \"https://github.com/PggMan/PGTimerDemo.git\", :tag =&gt; s.version &#125; // 下载路径、版本号 注意路径结尾必须添加.git。不然Cocopods不会会报警告\"- WARN | github_sources: Github repositories should end in `.git`.\" 不会通过的s.source_files = \"PGTimerDemo/PGTimer/*.&#123;h,m&#125;\"//被管理文件在项目中的路径s.exclude_files = \"Classes/Exclude\" //需要忽略管理文件夹内的文件s.public_header_files = \"iOS_Category/Classes/UIKit/UI_Categories.h\"，\"iOS_Category/Classes/Foundation/Foundation_Category.h\"，\"iOS_Category/Classes/**/*.h\" // 公开头文件路径s.requires_arc = true // 是否是ARC模式end Spec权限等级 1 请见附录一 2 权限文件内容 (直接复制到新建.txt文件中，重命名文件为: LICENSE) 1234567891011121314151617181920212223242526272829303132333435363738394041 Copyright (c) 2011-2018 PGTimerDemo Software Foundation (https://github.com/PggMan/PGTimerDemo)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. Spec操作123456789101112/**终端指令*/1.$ pod spec create PGTimer // 本地会生成PGTimer.podspec文件建议用Xcode 打开2.$ pod lib lint // 编辑完podspec文件后需要验证一下这个文件是否可用//#文件不允许有任何的Warning或者Error#3.$ git tag -m\" first release of my testDemo\" \"0.0.1\"$ git push --tags// 打tag podspec文件中需要指定的tag 每次上传新tag 版本 都需要更改spec文件中的tag配置描述 pod账号注册123456789101112131415161718192021/**注册*/$ pod trunk register pg890101@gmail.com 'PggMan' --verbose//1 pg890101@gmail.com 注册的邮箱，会发送信息至此邮箱//2 PggMan 用户名/**查看*/$ pod trunk me // 可以查看你已经注册的信息，其中包含你的name、email、since、Pods、sessions，其中Pods为你往CocoaPods提交的所有的Pod！/**把项目对应的podspec文件推送到Cocoapods服务上去*/$ pod trunk push PGTimer.podspec/**更改已Cocoapods已经经拥有的项目*/$ pod trunk add-owner PGTimer pg890101@gmail.com// CocoapodsDemo 框架名// 添加管理者的邮箱/**更新本地库*/$ pod repo update// 补充 问题1 上传后，pod search PGTimer 搜索不到 1 - 打开 Finder ,然后前往文件夹(快捷键: shift + command + G) ,输入以下地址:~/Library/Caches/CocoaPods/ 2 - 删除 search_index.json 这个文件,这个文件是 pod search 搜索时的缓存文件(本地索引库)。","categories":[],"tags":[]},{"title":"内存管理","slug":"内存管理","date":"2018-07-02T09:43:50.000Z","updated":"2018-07-16T13:32:59.469Z","comments":true,"path":"2018/07/02/内存管理/","link":"","permalink":"http://PGGMan.github.io/2018/07/02/内存管理/","excerpt":"","text":"iOS程序的内存布局 Tagged Point 1 从arm64开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。 2 在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用计数等、NSNumber指针存储的是堆中NSNunber对象的地址值。 3 使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。 4 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据(堆) 5 NSNumber、NSDate、NSString 也会调用objc_msgSend函数，此函数内部对Tagged Point进行了判断。 比如NSNumber的intValue方法，直接从指针中提取数据，节省了以后的调用开销(过程见 Runtime -&gt;objc_msgSend执行流程) Tagged Point判断方法 iOS平台：最高有效位是1 (第64bit) Mac平台: 最低有效位是1 (第0bit) OC对象内存管理 在iOS中，使用引用计数来管理OC对象的内存 一个新创建的OC对象的引用计数+1(1)，当引用计数为0，OC对象就会销毁，释放其占用的内存空间。 调用retain引用计数会+1，调用release会让OC对象的引用计数-1。 内存管理经验 当调用alloc、new、copy、mutableCopy、方法返回了一个对象。在不需要这个对象时，要调用release或者autorelease来释放它 想拥有某个对象，就让它的引用计数+1(retain)；不想再拥有某个对象，就让它的引用计数-1(release) 查看自动释放池 de 函数 私有函数，调用此函数会打印出自动释放池相关信息 1extern void _objc_autoreleasePoolPrint(void); 引用计数存储 isa_t -&gt; uintptr_t has_sidetable_rc 在64bit中，引用计数可以直接存储在优化过得isa指针中，也可能存储在SideTable类中(extra_rc 用19位来存储计数器相关数据,超出后会存储于 has_sidetable_rc结构体内(N - 1)) SideTable结构体中refcnts是一个存放着对象引用计数的散列表。 123456789101112131415161718192021222324252627struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() &#123; memset(&amp;weak_table, 0, sizeof(weak_table)); &#125; ~SideTable() &#123; _objc_fatal(\"Do not delete SideTable.\"); &#125; void lock() &#123; slock.lock(); &#125; void unlock() &#123; slock.unlock(); &#125; void forceReset() &#123; slock.forceReset(); &#125; template&lt;HaveOld, HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;HaveOld, HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);&#125;; 自动释放池 自动释放池的主要底层数据结构是: __AtAutoreleasePool、AutoreleasePoolPage。 调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的。 AutoreleasePoolPage是专属于某一个线程的,结构体内有一个thread属性用来存储它的归属线程。 @autoreleasepool{}的调用与__AtAutoreleasePool有关 12345678910111213141516// OC MRC 代码@autoreleasepool&#123;Person *person = [[Person alloc] init] autorelease];&#125;// 转成c++代码 相当于@autoreleasepool&#123; atautoreleasepoolobj = objc_autoreleasePoolPush(); // 开头调用 Person *person = [[Person alloc] init] autorelease]; objc_autoreleasePoolPop(atautoreleasepoolobj) // 结尾调用&#125; __AtAutoreleasePool的结构体 __AtAutoreleasePool结构体内定义了objc_autoreleasePoolPush()和 objc_autoreleasePoolPop()两个函数。 1234567891011121314151617181920// c++ 结构中可以定义函数struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123; // 构造函数。在创建结构体的时候调用 // atautoreleasepoolobj 是 POOL_BOUNDARY的地址值 atautoreleasepoolobj = objc_autoreleasePoolPush(); &#125; __AtAutoreleasePool() &#123;// 析构函数，在结构体销毁的时候调用 objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; void * atautoreleasepoolobj; &#125;; 123456789101112131415161718192021222324// 1void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;class AutoreleasePoolPage &#123; // 2 static inline void *push() &#123; id *dest; // POOL_BOUNDARY 常量 (Null) 最后返回的是它在page中的内存地址 if (DebugPoolAllocation) &#123; dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest; &#125; AutoreleasePoolPage的结构 自动释放池通过 __AtAutoreleasePool内部定义的函数来操作AutoreleasePoolPage来管理autorelease对象的地址 所有AutoreleasePoolPage对象通过双向链表的形式连接在一起。 每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址 每个AutoreleasePoolPage对象内有固定的7个属性(占56个字节),其余空间(4096 - 56 = 4040 字节)用于存储autorelease对象的内存地址 next指向了下一个能存放autorelease对象地址的区域 自动释放池操作流程结构体 @autoreleasepool @autoreleasepool通过__AtAutoreleasePool来操作，通过AutoreleasePoolPage来管理。 objc_autoreleasePoolPush() objc_autoreleasePoolPush() 是调用了 AutoreleasePoolPage结构体内定义的push()函数，首先，将POOL_BOUNDARY入栈，并返回其存储的内存地址 将N个autorelease对象按顺序存储到page中。 当前page满了，就会新创建一个page，把autorelease对象存储到新的page中。 objc_autoreleasePoolPop() objc_autoreleasePoolPop() 是调用了 AutoreleasePoolPage结构体内定义的pop()函数，调用此函数需要传入objc_autoreleasePoolPush()的返回值(POOL_BOUNDARY的内存地址) pop()会从hotpage（最后一页）的最后一个autorelease对象开始调用他们的release方法，直到遇到传入的内存地址，停止。 Runloop和Autorelease iOS在主线程的Runloop中注册了2个Observer 第一个Observer监听KCFRunLoopEntry事件，会调用objc_autoreleasePoolPush() 第二个Observer: 监听了KCFRunloopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、 objc_autoreleasePoolPush()函数 监听了KCFRunloopBeforeExit事件，会调用objc_autoreleasePoolPop() 属性修饰词 属性 - assign 1 - assign setting方法直接赋值。不会进行引用计数操作。 1@property (nonatomic ,assign) NSInteger age; 属性 - retain 2 - retain setting方法中会判断是不是新值；若是，会release旧值，retain新值 在dealloc中会 release释放对象。 1@property (nonatomic , retain) Dog *dog; 属性 - copy 3 - copy setting方法中会判断是不是新值；若是，会release旧值，copy新值 在dealloc中会 release释放对象 属性不存在 mutableCopy 操作 1@property (nonatomic , copy) NSArray *ary; 属性 - weak 4 - weak 不进行引用计数操作，在其指向对象销毁时，会进行一次清空操作 在setting方法中调用objc_storeWeak函数，会把weak指针在散列表中清除并清空weak指针清空。然后把赋值后的新weak 指针存储到当前OC对象的散列表中(sideTable -&gt; refonts(RefcountMap)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@property (nonatomic , weak) Person *p;/********************** 源码 **********************/idobjc_storeWeak(id *location, id newObj)&#123; return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object *)newObj);&#125;template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123; assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; // 旧得引用计数表, SideTable *newTable;// 操作排序顺序相关(锁) retry: if (haveOld) &#123; oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); if (haveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; &#125; if (haveNew &amp;&amp; newObj) &#123; Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); previouslyInitializedClass = cls; goto retry; &#125; &#125; // 此weak指针存储在引用计数结构体(sideTable)的散列表(refonts)中，将其取出清空 if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // 把新值存储到散列表中 if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; *location = (id)newObj; &#125; else &#123; &#125; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 属性 - strong 5 - strong在setting方法中会对传入的新值进行引用计数操作(retain),降低旧值引用计数(release) 123456789101112131415@property (nonatomic , strong) Person *p;/********************** 源码 **********************/voidobjc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); // retain新值 *location = obj; objc_release(prev); // release旧值&#125; OC指针修饰词 OC指针修饰词 - __strong 超出__strong修饰指针的作用域后才会释放。对引用计数进行了操作(+1) 123456789101112- (void)test &#123; __strong Person *p1; &#123; Person *p = [[Person alloc] init]; p1 = p; &#125; &#125;// p 释放 OC指针修饰词 - __weak __weak只是对其修饰指针指向的对象进行引用，并没有进行引用计数操作。在对象销毁时，会对对其修饰指针进行一次清空操作。 123456789101112- (void)test &#123; __weak Person *p2; &#123; Person *p = [[Person alloc] init]; p2 = p; &#125;// p 释放 &#125; OC指针修饰词 - __unsafe_unretained __unsafe_unretained 同__weak有些类似，只是对其修饰指针指向的对象进行引用，并没有进行引用计数操作.但是,不会对其修饰指针进行清空操作(还指向原来p的内存地址)。 12345678910111213- (void)test &#123; __unsafe_unretained Person *p2; &#123; Person *p = [[Person alloc] init]; p2 = p; &#125;// p 释放 // 此时 p2 仍然指向 p原来的内存地址 &#125; weak实现原理 关于weak的runtime源码 如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 1 - (void)dealloc &#123; _objc_rootDealloc(self);&#125;// 2 void_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125;// 3inline voidobjc_object::rootDealloc()&#123; if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; // 是否是优化过得isa !isa.weakly_referenced &amp;&amp; // 是否 没有 弱引用指向它 !isa.has_assoc &amp;&amp; // 是否 没有 关联对象 !isa.has_cxx_dtor &amp;&amp; // 是否 没有 c++析构函数 !isa.has_sidetable_rc)) // 是否 没有 另一个sidetable结构体存储引用计数相关 &#123; // 直接释放 assert(!sidetable_present()); free(this); &#125; else &#123; // 进行相关处理(释放关联对象、weak指针、sidetable 等) // 进行 4 5 object_dispose((id)this); &#125;&#125;// 4id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125;// 5void *objc_destructInstance(id obj) &#123; if (obj) &#123; bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); if (cxx) object_cxxDestruct(obj); // 销毁c++析构函数(销毁成员变量) if (assoc) _object_remove_assocations(obj); // 销毁关联对象 obj-&gt;clearDeallocating(); // 清空若指针 &#125; return obj;&#125;// 6 inline void objc_object::clearDeallocating()&#123; if (slowpath(!isa.nonpointer)) &#123; // 是普通指针 sidetable_clearDeallocating(); &#125; else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // 是优化过得isa指针 并且有弱引用指针指向它 clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125;// 7 NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); // 引用计数存储表(哈希表) SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; // 用对象的内存地址(this)作为key，去SideTables表里去除若指针进行清空 weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock();&#125; 总结一句话: weak修饰的对象指针指向的对象销毁时，会在该对象的dealloc函数中发送消息(调用函数)。去该对象的引用计数表中对weak指针进行清空操作。 copy与mutableCopy 最简洁的两点 1 改变新值不影响旧值，改变旧值不影响新值 2 copy出来的必是不可变，mutableCopy出来的必是可变","categories":[],"tags":[]}]}